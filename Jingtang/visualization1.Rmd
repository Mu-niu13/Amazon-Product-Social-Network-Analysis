---
title: 'PSTAT 194CS Final Project'
author: "Kai Wa Ho, Jingtang, Mu Niu"
date: "2024-06-03"
output: pdf_document
---


```{r, message=FALSE}
# library
library(readr)
library(igraph)
library(rsample)
library(plotly)
```


```{r}
amz <- readRDS(file = '../data/amz_igraph.rds')

amz
```


## Generate 4 Induced Subgraphs and Visualize the Networks:


Methodology: for each subgraph, randomly select one node from music, book, video, DVD, and keep retrieving the nodes that are connected/related to it until reach 200 nodes


* Nodes Retrieving Function:

```{r}
# Function to retrieve connected nodes up to a given count
retrieve_connected_nodes <- function(graph, start_node, count = 30) {
  # Initialize the list with the start node
  nodes_to_explore <- list(start_node)
  connected_nodes <- c(start_node)
  
  # Keep a list to avoid revisiting nodes
  visited_nodes <- numeric(0)
  
  # Explore the graph until we reach the desired number of nodes
  while (length(nodes_to_explore) > 0 && length(connected_nodes) < count) {
    current_node <- nodes_to_explore[[1]]
    nodes_to_explore <- nodes_to_explore[-1]  # Remove the explored node
    
    # Skip if already visited
    if (current_node %in% visited_nodes) next
    
    # Mark as visited
    visited_nodes <- c(visited_nodes, current_node)
    
    # Get neighbors and add to nodes to explore
    neighbors <- neighbors(graph, current_node)
    new_neighbors <- neighbors[!neighbors %in% connected_nodes]
    nodes_to_explore <- c(nodes_to_explore, as.list(new_neighbors))
    connected_nodes <- c(connected_nodes, new_neighbors)
    
    # Limit the collection if it exceeds the desired count
    if (length(connected_nodes) > count) {
      connected_nodes <- connected_nodes[1:count]
      break
    }
  }
  
  # Return the vertex sequence of connected nodes
  return(connected_nodes)
}
```



### Music:


```{r}
# music
set.seed(194)

# randomly select 1 node from music group
music.random = sample(V(amz)[V(amz)$group == "Music"], 1)

# apply function to get 200 related nodes
music.nodes = retrieve_connected_nodes(amz, music.random)
music.network <- induced_subgraph(amz, music.nodes)

# plot
# Choose a layout that spreads out the nodes more effectively
layout <- layout_with_fr(music.network)

# Set graph margins to zero
par(mar = c(0, 0, 2, 0))

# Plot the graph with improved layout and adjusted aesthetics
plot(music.network, layout = layout,
     # Vertex properties
     vertex.color = "#88398A",             # Deep purple color for vertices
     vertex.frame.color = "#FFFFFF",       # White border for vertices for better visibility
     vertex.size = 5,                      # Smaller vertex size to avoid overlap
     vertex.label = V(music.network)$name, # Ensure labels are set to product IDs or similar
     vertex.label.dist = 1,                # Distance of labels from vertices
     vertex.label.cex = 0.8,               # Adjust label size for readability
     vertex.label.color = "black",         # Change label color to black for contrast
     vertex.label.font = 2,                # Bold labels

     # Edge properties
     edge.color = "gray50",                # Lighter color for edges
     edge.width = 0.2,                     # Thinner edges
     edge.arrow.size = 0.1,                # Smaller arrows if directed

     # General plot settings
     main = "Music Products Base Plot", # Add a title if appropriate
     bg = "white" # Background color
)



# Color nodes based on a community detection algorithm to show clusters
music.cluster <- cluster_optimal(music.network)
mycomcols <- c("black", "#D3D3D3", "#88398A")


# Plot the graph with advanced layout and adjusted aesthetics
plot(music.network, layout = layout,
     # Vertex properties
     vertex.color = mycomcols[music.cluster$membership],        # Color vertices by community
     vertex.frame.color = "#FFFFFF",               # White border for vertices for better visibility
     vertex.size = sqrt(degree(music.network)) * 2, # Scale size by square root of degree
     vertex.label = V(music.network)$name,         # Labels are set to product IDs
     vertex.label.dist = 1,                        # Distance of labels from vertices
     vertex.label.cex = 0.6,                       # Adjust label size for readability
     vertex.label.color = "black",                 # Label color for contrast
     vertex.label.font = 2,                        # Bold labels

     # Edge properties
     edge.color = "gray50",                        # Lighter color for edges
     edge.width = 0.2,                             # Thinner edges
     edge.arrow.size = 0.1,                        # Smaller arrows if directed

     # General plot settings
     main = "Music Products Community", # Add a title
     bg = "white" # Background color
)


# Get vertex data including the degree for size scaling
vertex_data <- data.frame(
  Id = V(music.network)$name,
  x = layout[, 1],
  y = layout[, 2],
  degree = degree(music.network),
  Title = V(music.network)$title,
  Group = V(music.network)$group,
  Category = V(music.network)$sub
)

# Enhance hover info by including all attributes except x, y coordinates
vertex_data$hoverinfo <- apply(vertex_data[, -c(2, 3)], 1, function(row) {
  paste(names(row), row, sep=": ", collapse="<br>")
})

# Get edge data
edge_data <- get.data.frame(music.network, what = "edges")

# Join edge data with vertex data to get coordinates for 'from' and 'to'
edge_data <- merge(edge_data, vertex_data, by.x = "from", by.y = "Id", all.x = TRUE)
edge_data <- merge(edge_data, vertex_data, by.x = "to", by.y = "Id", all.x = TRUE, suffixes = c(".from", ".to"))

# Prepare data for Plotly plot
edges <- list(
  x = c(rbind(edge_data$x.from, edge_data$x.to, NA)),
  y = c(rbind(edge_data$y.from, edge_data$y.to, NA)),
  type = "scatter",
  mode = "lines",
  line = list(color = "grey", width = 0.5)
)

nodes <- list(
  x = vertex_data$x,
  y = vertex_data$y,
  hovertext = vertex_data$hoverinfo,
  mode = "markers",  # Only markers, no text
  marker = list(size = vertex_data$degree * 2,
                color = mycomcols[music.cluster$membership]),
  type = "scatter",
  hoverinfo = "text"
)

# Create the plot
plot_ly() %>%
  add_trace(x = edges$x, y = edges$y, mode = edges$mode, type = edges$type, line = edges$line) %>%
  add_trace(x = nodes$x, y = nodes$y, hovertext = nodes$hovertext, mode = nodes$mode, type = nodes$type, hoverinfo = "text", marker = nodes$marker) %>%
  layout(
    title = "Network Visualization of Music Products",
    xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    hovermode = 'closest'
    )
```

```{r}

print(music.network, full = TRUE)
```




### Book:


```{r}
# book
set.seed(194)

# randomly select 1 node from book group
book.random = sample(V(amz)[V(amz)$group == "Book"], 1)

# apply function to get 200 related nodes
book.nodes = retrieve_connected_nodes(amz, book.random)

book.network <- induced_subgraph(amz, book.nodes)

# plot
# Choose a layout that spreads out the nodes more effectively
layout <- layout_with_fr(book.network)

# Set graph margins to zero
par(mar = c(0, 0, 2, 0))

# Plot the graph with improved layout and adjusted aesthetics
plot(book.network, layout = layout,
     # Vertex properties
     vertex.color = "#88398A",             # Deep purple color for vertices
     vertex.frame.color = "#FFFFFF",       # White border for vertices for better visibility
     vertex.size = 5,                      # Smaller vertex size to avoid overlap
     vertex.label = V(book.network)$name, # Ensure labels are set to product IDs or similar
     vertex.label.dist = 1,                # Distance of labels from vertices
     vertex.label.cex = 0.8,               # Adjust label size for readability
     vertex.label.color = "black",         # Change label color to black for contrast
     vertex.label.font = 2,                # Bold labels

     # Edge properties
     edge.color = "gray50",                # Lighter color for edges
     edge.width = 0.2,                     # Thinner edges
     edge.arrow.size = 0.1,                # Smaller arrows if directed

     # General plot settings
     main = "Book Products Base Plot", # Add a title if appropriate
     bg = "white" # Background color
)



# Color nodes based on a community detection algorithm to show clusters
book.cluster <- cluster_optimal(book.network)
mycomcols <- c("black", "#D3D3D3", "#88398A")


# Plot the graph with advanced layout and adjusted aesthetics
plot(book.network, layout = layout,
     # Vertex properties
     vertex.color = mycomcols[book.cluster$membership],        # Color vertices by community
     vertex.frame.color = "#FFFFFF",               # White border for vertices for better visibility
     vertex.size = sqrt(degree(book.network)) * 2, # Scale size by square root of degree
     vertex.label = V(book.network)$name,         # Labels are set to product IDs
     vertex.label.dist = 1,                        # Distance of labels from vertices
     vertex.label.cex = 0.6,                       # Adjust label size for readability
     vertex.label.color = "black",                 # Label color for contrast
     vertex.label.font = 2,                        # Bold labels

     # Edge properties
     edge.color = "gray50",                        # Lighter color for edges
     edge.width = 0.2,                             # Thinner edges
     edge.arrow.size = 0.1,                        # Smaller arrows if directed

     # General plot settings
     main = "Book Products Community", # Add a title
     bg = "white" # Background color
)


# Get vertex data including the degree for size scaling
vertex_data <- data.frame(
  Id = V(book.network)$name,
  x = layout[, 1],
  y = layout[, 2],
  degree = degree(book.network),
  Title = V(book.network)$title,
  Group = V(book.network)$group,
  Category = V(book.network)$sub
)

# Enhance hover info by including all attributes except x, y coordinates
vertex_data$hoverinfo <- apply(vertex_data[, -c(2, 3)], 1, function(row) {
  paste(names(row), row, sep=": ", collapse="<br>")
})

# Get edge data
edge_data <- get.data.frame(book.network, what = "edges")

# Join edge data with vertex data to get coordinates for 'from' and 'to'
edge_data <- merge(edge_data, vertex_data, by.x = "from", by.y = "Id", all.x = TRUE)
edge_data <- merge(edge_data, vertex_data, by.x = "to", by.y = "Id", all.x = TRUE, suffixes = c(".from", ".to"))

# Prepare data for Plotly plot
edges <- list(
  x = c(rbind(edge_data$x.from, edge_data$x.to, NA)),
  y = c(rbind(edge_data$y.from, edge_data$y.to, NA)),
  type = "scatter",
  mode = "lines",
  line = list(color = "grey", width = 0.5)
)

nodes <- list(
  x = vertex_data$x,
  y = vertex_data$y,
  hovertext = vertex_data$hoverinfo,
  mode = "markers",  # Only markers, no text
  marker = list(size = vertex_data$degree * 2,
                color = mycomcols[book.cluster$membership]),
  type = "scatter",
  hoverinfo = "text"
)

# Create the plot
plot_ly() %>%
  add_trace(x = edges$x, y = edges$y, mode = edges$mode, type = edges$type, line = edges$line) %>%
  add_trace(x = nodes$x, y = nodes$y, hovertext = nodes$hovertext, mode = nodes$mode, type = nodes$type, hoverinfo = "text", marker = nodes$marker) %>%
  layout(
    title = "Network Visualization of Book Products",
    xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    hovermode = 'closest'
    )
```



### Video:


```{r}
# music
set.seed(194)

# randomly select 1 node from video group
video.random = sample(V(amz)[V(amz)$group == "Video"], 1)

# apply function to get 200 related nodes
video.nodes = retrieve_connected_nodes(amz, video.random)

video.network <- induced_subgraph(amz, video.nodes)

# plot
# Choose a layout that spreads out the nodes more effectively
layout <- layout_with_fr(video.network)

# Set graph margins to zero
par(mar = c(0, 0, 2, 0))

# Plot the graph with improved layout and adjusted aesthetics
plot(video.network, layout = layout,
     # Vertex properties
     vertex.color = "#88398A",             # Deep purple color for vertices
     vertex.frame.color = "#FFFFFF",       # White border for vertices for better visibility
     vertex.size = 5,                      # Smaller vertex size to avoid overlap
     vertex.label = V(video.network)$name, # Ensure labels are set to product IDs or similar
     vertex.label.dist = 1,                # Distance of labels from vertices
     vertex.label.cex = 0.8,               # Adjust label size for readability
     vertex.label.color = "black",         # Change label color to black for contrast
     vertex.label.font = 2,                # Bold labels

     # Edge properties
     edge.color = "gray50",                # Lighter color for edges
     edge.width = 0.2,                     # Thinner edges
     edge.arrow.size = 0.1,                # Smaller arrows if directed

     # General plot settings
     main = "Video Products Base Plot", # Add a title if appropriate
     bg = "white" # Background color
)



# Color nodes based on a community detection algorithm to show clusters
video.cluster <- cluster_optimal(video.network)
mycomcols <- c("black", "#D3D3D3", "#88398A")


# Plot the graph with advanced layout and adjusted aesthetics
plot(video.network, layout = layout,
     # Vertex properties
     vertex.color = mycomcols[video.cluster$membership],        # Color vertices by community
     vertex.frame.color = "#FFFFFF",               # White border for vertices for better visibility
     vertex.size = sqrt(degree(video.network)) * 2, # Scale size by square root of degree
     vertex.label = V(video.network)$name,         # Labels are set to product IDs
     vertex.label.dist = 1,                        # Distance of labels from vertices
     vertex.label.cex = 0.6,                       # Adjust label size for readability
     vertex.label.color = "black",                 # Label color for contrast
     vertex.label.font = 2,                        # Bold labels

     # Edge properties
     edge.color = "gray50",                        # Lighter color for edges
     edge.width = 0.2,                             # Thinner edges
     edge.arrow.size = 0.1,                        # Smaller arrows if directed

     # General plot settings
     main = "Video Products Community", # Add a title
     bg = "white" # Background color
)


# Get vertex data including the degree for size scaling
vertex_data <- data.frame(
  Id = V(video.network)$name,
  x = layout[, 1],
  y = layout[, 2],
  degree = degree(video.network),
  Title = V(video.network)$title,
  Group = V(video.network)$group,
  Category = V(video.network)$sub
)

# Enhance hover info by including all attributes except x, y coordinates
vertex_data$hoverinfo <- apply(vertex_data[, -c(2, 3)], 1, function(row) {
  paste(names(row), row, sep=": ", collapse="<br>")
})

# Get edge data
edge_data <- get.data.frame(video.network, what = "edges")

# Join edge data with vertex data to get coordinates for 'from' and 'to'
edge_data <- merge(edge_data, vertex_data, by.x = "from", by.y = "Id", all.x = TRUE)
edge_data <- merge(edge_data, vertex_data, by.x = "to", by.y = "Id", all.x = TRUE, suffixes = c(".from", ".to"))

# Prepare data for Plotly plot
edges <- list(
  x = c(rbind(edge_data$x.from, edge_data$x.to, NA)),
  y = c(rbind(edge_data$y.from, edge_data$y.to, NA)),
  type = "scatter",
  mode = "lines",
  line = list(color = "grey", width = 0.5)
)

nodes <- list(
  x = vertex_data$x,
  y = vertex_data$y,
  hovertext = vertex_data$hoverinfo,
  mode = "markers",  # Only markers, no text
  marker = list(size = vertex_data$degree * 2,
                color = mycomcols[video.cluster$membership]),
  type = "scatter",
  hoverinfo = "text"
)

# Create the plot
plot_ly() %>%
  add_trace(x = edges$x, y = edges$y, mode = edges$mode, type = edges$type, line = edges$line) %>%
  add_trace(x = nodes$x, y = nodes$y, hovertext = nodes$hovertext, mode = nodes$mode, type = nodes$type, hoverinfo = "text", marker = nodes$marker) %>%
  layout(
    title = "Network Visualization of Video Products",
    xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    hovermode = 'closest'
    )
```


### DVD:


```{r}
# music
set.seed(194)

# randomly select 1 node from music group
dvd.random = sample(V(amz)[V(amz)$group == "DVD"], 1)

# apply function to get 200 related nodes
dvd.nodes = retrieve_connected_nodes(amz, dvd.random)

dvd.network <- induced_subgraph(amz, dvd.nodes)

# plot
# Choose a layout that spreads out the nodes more effectively
layout <- layout_with_fr(dvd.network)

# Set graph margins to zero
par(mar = c(0, 0, 2, 0))

# Plot the graph with improved layout and adjusted aesthetics
plot(dvd.network, layout = layout,
     # Vertex properties
     vertex.color = "#88398A",             # Deep purple color for vertices
     vertex.frame.color = "#FFFFFF",       # White border for vertices for better visibility
     vertex.size = 5,                      # Smaller vertex size to avoid overlap
     vertex.label = V(dvd.network)$name, # Ensure labels are set to product IDs or similar
     vertex.label.dist = 1,                # Distance of labels from vertices
     vertex.label.cex = 0.8,               # Adjust label size for readability
     vertex.label.color = "black",         # Change label color to black for contrast
     vertex.label.font = 2,                # Bold labels

     # Edge properties
     edge.color = "gray50",                # Lighter color for edges
     edge.width = 0.2,                     # Thinner edges
     edge.arrow.size = 0.1,                # Smaller arrows if directed

     # General plot settings
     main = "DVD Products Base Plot", # Add a title if appropriate
     bg = "white" # Background color
)



# Color nodes based on a community detection algorithm to show clusters
dvd.cluster <- cluster_optimal(dvd.network)
mycomcols <- c("black", "#D3D3D3", "#88398A")


# Plot the graph with advanced layout and adjusted aesthetics
plot(dvd.network, layout = layout,
     # Vertex properties
     vertex.color = mycomcols[dvd.cluster$membership],        # Color vertices by community
     vertex.frame.color = "#FFFFFF",               # White border for vertices for better visibility
     vertex.size = sqrt(degree(dvd.network)) * 2, # Scale size by square root of degree
     vertex.label = V(dvd.network)$name,         # Labels are set to product IDs
     vertex.label.dist = 1,                        # Distance of labels from vertices
     vertex.label.cex = 0.6,                       # Adjust label size for readability
     vertex.label.color = "black",                 # Label color for contrast
     vertex.label.font = 2,                        # Bold labels

     # Edge properties
     edge.color = "gray50",                        # Lighter color for edges
     edge.width = 0.2,                             # Thinner edges
     edge.arrow.size = 0.1,                        # Smaller arrows if directed

     # General plot settings
     main = "DVD Products Community", # Add a title
     bg = "white" # Background color
)


# Get vertex data including the degree for size scaling
vertex_data <- data.frame(
  Id = V(dvd.network)$name,
  x = layout[, 1],
  y = layout[, 2],
  degree = degree(dvd.network),
  Title = V(dvd.network)$title,
  Group = V(dvd.network)$group,
  Category = V(dvd.network)$sub
)

# Enhance hover info by including all attributes except x, y coordinates
vertex_data$hoverinfo <- apply(vertex_data[, -c(2, 3)], 1, function(row) {
  paste(names(row), row, sep=": ", collapse="<br>")
})

# Get edge data
edge_data <- get.data.frame(dvd.network, what = "edges")

# Join edge data with vertex data to get coordinates for 'from' and 'to'
edge_data <- merge(edge_data, vertex_data, by.x = "from", by.y = "Id", all.x = TRUE)
edge_data <- merge(edge_data, vertex_data, by.x = "to", by.y = "Id", all.x = TRUE, suffixes = c(".from", ".to"))

# Prepare data for Plotly plot
edges <- list(
  x = c(rbind(edge_data$x.from, edge_data$x.to, NA)),
  y = c(rbind(edge_data$y.from, edge_data$y.to, NA)),
  type = "scatter",
  mode = "lines",
  line = list(color = "grey", width = 0.5)
)

nodes <- list(
  x = vertex_data$x,
  y = vertex_data$y,
  hovertext = vertex_data$hoverinfo,
  mode = "markers",  # Only markers, no text
  marker = list(size = vertex_data$degree * 2,
                color = mycomcols[dvd.cluster$membership]),
  type = "scatter",
  hoverinfo = "text"
)

# Create the plot
plot_ly() %>%
  add_trace(x = edges$x, y = edges$y, mode = edges$mode, type = edges$type, line = edges$line) %>%
  add_trace(x = nodes$x, y = nodes$y, hovertext = nodes$hovertext, mode = nodes$mode, type = nodes$type, hoverinfo = "text", marker = nodes$marker) %>%
  layout(
    title = "Network Visualization of DVD Products",
    xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    hovermode = 'closest'
    )
```







## 4. Analyze Network Metrics
***Music***
```{r}
# Network Metrics
# Density
network_density <- edge_density(music.network)
cat("Network Density:", network_density, "\n")

# Average Path Length
avg_path_length <- average.path.length(music.network, directed = FALSE)
cat("Average Path Length:", avg_path_length, "\n")

# Diameter
network_diameter <- diameter(music.network, directed = FALSE)
cat("Network Diameter:", network_diameter, "\n")

# Node Metrics
# Degree
node_degree <- degree(music.network)
cat("Node Degree:\n")
print(summary(node_degree))

# Betweenness Centrality
node_betweenness <- betweenness(music.network)
cat("Node Betweenness Centrality:\n")
print(summary(node_betweenness))

# Closeness Centrality
node_closeness <- closeness(music.network)
cat("Node Closeness Centrality:\n")
print(summary(node_closeness))

# Eigenvector Centrality
node_eigenvector <- evcent(music.network)$vector
cat("Node Eigenvector Centrality:\n")
print(summary(node_eigenvector))

# Edge Metrics
# Edge Betweenness
edge_betweenness <- edge.betweenness(music.network)
cat("Edge Betweenness:\n")
print(summary(edge_betweenness))
```
***Network Density: 0.2367816***        
The density of the network is approximately 0.237, which means that about 23.7% of all possible edges between nodes are present. This indicates a moderately connected network, suggesting that a fair number of music products are frequently co-purchased or associated with each other, but there is still a significant proportion that are not directly connected.
    
***Average Path Length: 1.889655***       
The average number of steps along the shortest paths for all possible pairs of nodes is about 1.89. This relatively short path length implies that, on average, any two music products in this network are separated by less than two steps, indicating that products are closely related and often co-purchased.
    
***Network Diameter: 3***       
The diameter of the network is 3, which is the longest shortest path between any two nodes in the network. This small diameter suggests that the network is compact, meaning that even the most distantly related products are not far apart in terms of purchase patterns.
    
***Node Degree***       
The degree distribution shows that the minimum degree is 3, and the maximum degree is 27. The median degree is 14, indicating that half of the nodes have at least 14 connections. The mean degree is about 13.73, showing a relatively balanced distribution of connections among nodes. Nodes with higher degrees are likely popular music products frequently purchased with many others.
    
***Node Betweenness Centrality***
Betweenness centrality measures the extent to which a node lies on paths between other nodes. A high mean value (33.767) and a maximum value (185.015) indicate that certain nodes play critical roles as bridges or connectors in the network. These nodes are essential for maintaining the network's overall connectivity and can be key products influencing purchase patterns.
    
***Node Closeness Centrality***
Closeness centrality measures how close a node is to all other nodes in the network. Nodes with higher closeness centrality (closer to the maximum value of 0.02041) can quickly interact with all other nodes, making them influential in spreading information or trends within the network.
    
***Node Eigenvector Centrality***
Eigenvector centrality assigns relative scores to all nodes based on the principle that connections to high-scoring nodes contribute more to the score of the node in question. The maximum value of 1.0 and a mean of 0.46907 indicate that some nodes are highly influential, connected to other well-connected nodes, making them central in the network.
    
***Edge Metrics***
Edge betweenness measures the number of times an edge is part of the shortest path between any two nodes. A mean of 9.141 and a maximum of 71 indicate that some edges are crucial for maintaining the network's structure. These edges often represent key relationships between products that are essential for the flow of connections within the network.
    
***Summary***
The metrics indicate that the music products network is moderately dense, compact, and features nodes and edges with varying levels of influence and connectivity. Some nodes and edges are critical for maintaining the network's overall structure, indicating popular or influential music products and key associations among them.


***Book***
```{r}
# Network Metrics
# Density
network_density <- edge_density(book.network)
cat("Network Density:", network_density, "\n")

# Average Path Length
avg_path_length <- average.path.length(book.network, directed = FALSE)
cat("Average Path Length:", avg_path_length, "\n")

# Diameter
network_diameter <- diameter(book.network, directed = FALSE)
cat("Network Diameter:", network_diameter, "\n")

# Node Metrics
# Degree
node_degree <- degree(book.network)
cat("Node Degree:\n")
print(summary(node_degree))

# Betweenness Centrality
node_betweenness <- betweenness(book.network)
cat("Node Betweenness Centrality:\n")
print(summary(node_betweenness))

# Closeness Centrality
node_closeness <- closeness(book.network)
cat("Node Closeness Centrality:\n")
print(summary(node_closeness))

# Eigenvector Centrality
node_eigenvector <- evcent(book.network)$vector
cat("Node Eigenvector Centrality:\n")
print(summary(node_eigenvector))

# Edge Metrics
# Edge Betweenness
edge_betweenness <- edge.betweenness(book.network)
cat("Edge Betweenness:\n")
print(summary(edge_betweenness))

```



***Video***
```{r}
# Network Metrics
# Density
network_density <- edge_density(video.network)
cat("Network Density:", network_density, "\n")

# Average Path Length
avg_path_length <- average.path.length(video.network, directed = FALSE)
cat("Average Path Length:", avg_path_length, "\n")

# Diameter
network_diameter <- diameter(video.network, directed = FALSE)
cat("Network Diameter:", network_diameter, "\n")

# Node Metrics
# Degree
node_degree <- degree(video.network)
cat("Node Degree:\n")
print(summary(node_degree))

# Betweenness Centrality
node_betweenness <- betweenness(video.network)
cat("Node Betweenness Centrality:\n")
print(summary(node_betweenness))

# Closeness Centrality
node_closeness <- closeness(video.network)
cat("Node Closeness Centrality:\n")
print(summary(node_closeness))

# Eigenvector Centrality
node_eigenvector <- evcent(video.network)$vector
cat("Node Eigenvector Centrality:\n")
print(summary(node_eigenvector))

# Edge Metrics
# Edge Betweenness
edge_betweenness <- edge.betweenness(video.network)
cat("Edge Betweenness:\n")
print(summary(edge_betweenness))

```


## 5. Community Detection
***Music***
```{r}
# Community Detection
# Walktrap Algorithm
walktrap_communities <- cluster_walktrap(music.network)
cat("Walktrap Algorithm:\n")
print(membership(walktrap_communities))
cat("Modularity:", modularity(walktrap_communities), "\n")

# Infomap Algorithm
infomap_communities <- cluster_infomap(music.network)
cat("Infomap Algorithm:\n")
print(membership(infomap_communities))
cat("Modularity:", modularity(infomap_communities), "\n")

# Visualize communities (optional)
par(mfrow=c(1,3))
plot(walktrap_communities, music.network, main="Walktrap Algorithm", vertex.size=10, edge.arrow.size=0.05, vertex.label.cex=0.7, vertex.label.color="black")
plot(infomap_communities, music.network, main="Infomap Algorithm", vertex.size=10, edge.arrow.size=0.05, vertex.label.cex=0.7, vertex.label.color="black")
```


## Adjacency Matrix&Reorder Nodes

### Music

#### original matrix
```{r}

edges_list_M <- as_edgelist(music.network, names = TRUE)

igraph_network_M <- graph.edgelist(edges_list_M, directed = TRUE)

network.adjacency_M <- as_adj(igraph_network_M)

network.adjacency_M

image(Matrix(network.adjacency_M))


```


```{r}

# Create the adjacency matrix
adj_matrix <- as_adjacency_matrix(music.network, sparse = FALSE)

# Set up the plot with customizations
par(mar = c(5, 5, 4, 2) + 0.1)  # Increase margins for axis labels

# Visualize the adjacency matrix with gridlines and node labels
image(1:nrow(adj_matrix), 1:ncol(adj_matrix), adj_matrix, 
      main = "Adjacency Matrix For Music", 
      xlab = "Nodes", ylab = "Nodes", 
      axes = FALSE, col = c("white", "black"))



# Add axis labels
axis(1, at = 1:nrow(adj_matrix), labels = rownames(adj_matrix), las = 2, cex.axis = 0.7, tick = FALSE)
axis(2, at = 1:ncol(adj_matrix), labels = colnames(adj_matrix), las = 2, cex.axis = 0.7, tick = FALSE)

```

#### Reordering

##### hierachical clustering to highlight
```{r}
# Hierarchical clustering to reorder the adjacency matrix
d <- dist(adj_matrix) # Distance matrix
hc <- hclust(d)       # Hierarchical clustering
order <- hc$order     # Order of the nodes

# Reorder the adjacency matrix
adj_matrix_reordered <- adj_matrix[order, order]

# Set up the plot with customizations
par(mar = c(5, 5, 4, 2) + 0.1)  # Increase margins for axis labels

# Plot the reordered adjacency matrix with gridlines and node labels
image(1:nrow(adj_matrix_reordered), 1:ncol(adj_matrix_reordered), adj_matrix_reordered, 
      main = "Reordered Adjacency Matrix For Music", 
      xlab = "Nodes", ylab = "Nodes", 
      axes = FALSE, col = c("lightpink", "darkblue"))

# Add gridlines
grid(nx = nrow(adj_matrix_reordered), ny = ncol(adj_matrix_reordered), col = "gray", lty = "dotted")

# Add axis labels
axis(1, at = 1:nrow(adj_matrix_reordered), labels = rownames(adj_matrix_reordered), las = 2, cex.axis = 0.7, tick = FALSE)
axis(2, at = 1:ncol(adj_matrix_reordered), labels = colnames(adj_matrix_reordered), las = 2, cex.axis = 0.7, tick = FALSE)
```

##### based on community
Since we can not directly apply the fast greedy alogorithm we learned to our directed network, I decided to test different alogrithms, by applying the walktrap alogrithm to our original network, meanwhile change the original network into an undirected one then apply the fast greedy method to see which one has higher modularity and how different are the communities and reordered matrices. 

###### directed
```{r}
# Detect communities
communities <- cluster_walktrap(music.network)

# Get the membership vector
membership <- membership(communities)

# Calculate modularity to quantify the strength of the detected communities
modularity_value <- modularity(communities)
print(paste("Modularity:", modularity_value))

# Identify the number of communities
num_communities <- length(unique(membership))
print(paste("Number of Communities:", num_communities))

# List the members of each community
community_list <- split(V(music.network)$name, membership)
community_list

# Reorder the nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(music.network))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(ordered_adjacency_matrix, main="Reordered Adjacency Matrix Based on Community for Music Network", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(music.network)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(music.network)$name[ordered_indices], las=2, cex.axis=0.7)

```

###### undirected
```{r}

# change the network to undirected
undirected_music_network <- as.undirected(music.network, mode="collapse")

# Detect communities using the walktrap algorithm
communities <- cluster_fast_greedy(undirected_music_network)

membership <- membership(communities)

# Calculate modularity to quantify the strength of the detected communities
modularity_value <- modularity(communities)
print(paste("Modularity:", modularity_value))

# Identify the number of communities
num_communities <- length(unique(membership))
print(paste("Number of Communities:", num_communities))

# List the members of each community
community_list <- split(V(undirected_music_network)$name, membership)
community_list



# Reorder nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(undirected_music_network))[ordered_indices, ordered_indices]

# Plot reordered adjacency matrix with community colors
image(1:nrow(ordered_adjacency_matrix), 1:ncol(ordered_adjacency_matrix), ordered_adjacency_matrix, col=c("white", "black"), main="Reordered Adjacency Matrix Based on Community", axes=FALSE, )
axis(1, at=1:nrow(ordered_adjacency_matrix), labels=V(undirected_music_network)$name[ordered_indices], las=2, cex.axis=0.5)
axis(2, at=1:ncol(ordered_adjacency_matrix), labels=V(undirected_music_network)$name[ordered_indices], las=2, cex.axis=0.5)
```


### Book

#### original matrix

```{r}
edges_list_B <- as_edgelist(book.network, names = TRUE)


igraph_network_B <- graph.edgelist(edges_list_B, directed = TRUE)

network.adjacency_B <- as_adj(igraph_network_B)

network.adjacency_B

image(Matrix(network.adjacency_B))
```

```{r}
# Create the adjacency matrix
adj_matrix <- as_adjacency_matrix(book.network, sparse = FALSE)

# Set up the plot with customizations
par(mar = c(5, 5, 4, 2) + 0.1)  # Increase margins for axis labels

# Visualize the adjacency matrix with gridlines and node labels
image(1:nrow(adj_matrix), 1:ncol(adj_matrix), adj_matrix, 
      main = "Adjacency Matrix For Books", 
      xlab = "Nodes", ylab = "Nodes", 
      axes = FALSE, col = c("white", "black"))


# Add axis labels
axis(1, at = 1:nrow(adj_matrix), labels = rownames(adj_matrix), las = 2, cex.axis = 0.7, tick = FALSE)
axis(2, at = 1:ncol(adj_matrix), labels = colnames(adj_matrix), las = 2, cex.axis = 0.7, tick = FALSE)

```

#### Reordering

##### hierachical clustering to highlight

```{r}
### Reorder vertices to highlight patterns.
# Hierarchical clustering to reorder the adjacency matrix
d <- dist(adj_matrix) # Distance matrix
hc <- hclust(d)       # Hierarchical clustering
order <- hc$order     # Order of the nodes

# Reorder the adjacency matrix
adj_matrix_reordered <- adj_matrix[order, order]

# Set up the plot with customizations
par(mar = c(5, 5, 4, 2) + 0.1)  # Increase margins for axis labels

# Plot the reordered adjacency matrix with gridlines and node labels
image(1:nrow(adj_matrix_reordered), 1:ncol(adj_matrix_reordered), adj_matrix_reordered, 
      main = "Reordered Adjacency Matrix For Books", 
      xlab = "Nodes", ylab = "Nodes", 
      axes = FALSE, col = c("lightpink", "darkblue"))

# Add gridlines
grid(nx = nrow(adj_matrix_reordered), ny = ncol(adj_matrix_reordered), col = "gray", lty = "dotted")

# Add axis labels
axis(1, at = 1:nrow(adj_matrix_reordered), labels = rownames(adj_matrix_reordered), las = 2, cex.axis = 0.7, tick = FALSE)
axis(2, at = 1:ncol(adj_matrix_reordered), labels = colnames(adj_matrix_reordered), las = 2, cex.axis = 0.7, tick = FALSE)
```

##### based on community

###### directed

```{r}
# Detect communities
communities <- cluster_walktrap(book.network)

# Get the membership vector
membership <- membership(communities)

# Calculate modularity to quantify the strength of the detected communities
modularity_value <- modularity(communities)
print(paste("Modularity:", modularity_value))

# Identify the number of communities
num_communities <- length(unique(membership))
print(paste("Number of Communities:", num_communities))

# List the members of each community
community_list <- split(V(book.network)$name, membership)
community_list

# Reorder the nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(book.network))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(ordered_adjacency_matrix, main="Reordered Adjacency Matrix Based on Community for Music Network", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(book.network)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(book.network)$name[ordered_indices], las=2, cex.axis=0.7)

```


###### undirected
```{r}
# change the network to undirected
undirected_book_network <- as.undirected(book.network, mode="collapse")

# Detect communities using the fastgreedy algorithm
communities <- cluster_fast_greedy(undirected_book_network)

# Get the membership vector
membership <- membership(communities)

# Calculate modularity to quantify the strength of the detected communities
modularity_value <- modularity(communities)
print(paste("Modularity:", modularity_value))

# Identify the number of communities
num_communities <- length(unique(membership))
print(paste("Number of Communities:", num_communities))

# List the members of each community
community_list <- split(V(undirected_book_network)$name, membership)
community_list

# Reorder the nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(undirected_book_network))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(ordered_adjacency_matrix, main="Reordered Adjacency Matrix Based on Community", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(undirected_book_network)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(undirected_book_network)$name[ordered_indices], las=2, cex.axis=0.7)
```

### Video

#### Original Matrix

#### Reordering

```{r}
edges_list_V <- as_edgelist(video.network, names = TRUE)


igraph_network_V <- graph.edgelist(edges_list_V, directed = TRUE)

network.adjacency_V <- as_adj(igraph_network_V)

network.adjacency_V

image(Matrix(network.adjacency_V))
```

```{r}
# Create the adjacency matrix
adj_matrix <- as_adjacency_matrix(video.network, sparse = FALSE)

# Set up the plot with customizations
par(mar = c(5, 5, 4, 2) + 0.1)  # Increase margins for axis labels

# Visualize the adjacency matrix with gridlines and node labels
image(1:nrow(adj_matrix), 1:ncol(adj_matrix), adj_matrix, 
      main = "Adjacency Matrix For Videos", 
      xlab = "Nodes", ylab = "Nodes", 
      axes = FALSE, col = c("white", "black"))


# Add axis labels
axis(1, at = 1:nrow(adj_matrix), labels = rownames(adj_matrix), las = 2, cex.axis = 0.7, tick = FALSE)
axis(2, at = 1:ncol(adj_matrix), labels = colnames(adj_matrix), las = 2, cex.axis = 0.7, tick = FALSE)
```

##### Hierarchical clustering

```{r}
# Hierarchical clustering to reorder the adjacency matrix
d <- dist(adj_matrix) # Distance matrix
hc <- hclust(d)       # Hierarchical clustering
order <- hc$order     # Order of the nodes

# Reorder the adjacency matrix
adj_matrix_reordered <- adj_matrix[order, order]

# Set up the plot with customizations
par(mar = c(5, 5, 4, 2) + 0.1)  # Increase margins for axis labels

# Plot the reordered adjacency matrix with gridlines and node labels
image(1:nrow(adj_matrix_reordered), 1:ncol(adj_matrix_reordered), adj_matrix_reordered, 
      main = "Reordered Adjacency Matrix For Videos", 
      xlab = "Nodes", ylab = "Nodes", 
      axes = FALSE, col = c("lightpink", "darkblue"))

# Add gridlines
grid(nx = nrow(adj_matrix_reordered), ny = ncol(adj_matrix_reordered), col = "gray", lty = "dotted")

# Add axis labels
axis(1, at = 1:nrow(adj_matrix_reordered), labels = rownames(adj_matrix_reordered), las = 2, cex.axis = 0.7, tick = FALSE)
axis(2, at = 1:ncol(adj_matrix_reordered), labels = colnames(adj_matrix_reordered), las = 2, cex.axis = 0.7, tick = FALSE)
```

##### based on community

###### directed
```{r}
# Detect communities
communities <- cluster_walktrap(video.network)

# Get the membership vector
membership <- membership(communities)

# Calculate modularity to quantify the strength of the detected communities
modularity_value <- modularity(communities)
print(paste("Modularity:", modularity_value))

# Identify the number of communities
num_communities <- length(unique(membership))
print(paste("Number of Communities:", num_communities))

# List the members of each community
community_list <- split(V(video.network)$name, membership)
community_list

# Reorder the nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(video.network))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(ordered_adjacency_matrix, main="Reordered Adjacency Matrix Based on Community for Music Network", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(video.network)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(video.network)$name[ordered_indices], las=2, cex.axis=0.7)
```

###### undirected
```{r}
# change the network to undirected
undirected_video_network <- as.undirected(video.network, mode="collapse")

# Detect communities using the fastgreedy algorithm
communities <- cluster_fast_greedy(undirected_video_network)

# Get the membership vector
membership <- membership(communities)

# Calculate modularity to quantify the strength of the detected communities
modularity_value <- modularity(communities)
print(paste("Modularity:", modularity_value))

# Identify the number of communities
num_communities <- length(unique(membership))
print(paste("Number of Communities:", num_communities))

# List the members of each community
community_list <- split(V(undirected_video_network)$name, membership)
community_list

# Reorder the nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(undirected_video_network))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(ordered_adjacency_matrix, main="Reordered Adjacency Matrix Based on Community", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(undirected_video_network)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(undirected_video_network)$name[ordered_indices], las=2, cex.axis=0.7)
```


### DVD

#### Original Matrix

```{r}
edges_list_D <- as_edgelist(dvd.network, names = TRUE)


igraph_network_D <- graph.edgelist(edges_list_D, directed = TRUE)

network.adjacency_D <- as_adj(igraph_network_D)

network.adjacency_D

image(Matrix(network.adjacency_D))
```

```{r}
# Create the adjacency matrix
adj_matrix <- as_adjacency_matrix(dvd.network, sparse = FALSE)

# Set up the plot with customizations
par(mar = c(5, 5, 4, 2) + 0.1)  # Increase margins for axis labels

# Visualize the adjacency matrix with gridlines and node labels
image(1:nrow(adj_matrix), 1:ncol(adj_matrix), adj_matrix, 
      main = "Adjacency Matrix For DVD", 
      xlab = "Nodes", ylab = "Nodes", 
      axes = FALSE, col = c("white", "black"))



# Add axis labels
axis(1, at = 1:nrow(adj_matrix), labels = rownames(adj_matrix), las = 2, cex.axis = 0.7, tick = FALSE)
axis(2, at = 1:ncol(adj_matrix), labels = colnames(adj_matrix), las = 2, cex.axis = 0.7, tick = FALSE)

```


#### Reordering

##### Hierarchical clustering
```{r}
### Reorder vertices to highlight patterns.
# Hierarchical clustering to reorder the adjacency matrix
d <- dist(adj_matrix) # Distance matrix
hc <- hclust(d)       # Hierarchical clustering
order <- hc$order     # Order of the nodes

# Reorder the adjacency matrix
adj_matrix_reordered <- adj_matrix[order, order]

# Set up the plot with customizations
par(mar = c(5, 5, 4, 2) + 0.1)  # Increase margins for axis labels

# Plot the reordered adjacency matrix with gridlines and node labels
image(1:nrow(adj_matrix_reordered), 1:ncol(adj_matrix_reordered), adj_matrix_reordered, 
      main = "Reordered Adjacency Matrix For DVD", 
      xlab = "Nodes", ylab = "Nodes", 
      axes = FALSE, col = c("lightpink", "darkblue"))

# Add gridlines
grid(nx = nrow(adj_matrix_reordered), ny = ncol(adj_matrix_reordered), col = "gray", lty = "dotted")

# Add axis labels
axis(1, at = 1:nrow(adj_matrix_reordered), labels = rownames(adj_matrix_reordered), las = 2, cex.axis = 0.7, tick = FALSE)
axis(2, at = 1:ncol(adj_matrix_reordered), labels = colnames(adj_matrix_reordered), las = 2, cex.axis = 0.7, tick = FALSE)
```

##### based on community

###### directed
```{r}
# Detect communities
communities <- cluster_walktrap(dvd.network)

# Get the membership vector
membership <- membership(communities)

# Calculate modularity to quantify the strength of the detected communities
modularity_value <- modularity(communities)
print(paste("Modularity:", modularity_value))

# Identify the number of communities
num_communities <- length(unique(membership))
print(paste("Number of Communities:", num_communities))

# List the members of each community
community_list <- split(V(dvd.network)$name, membership)
community_list

# Reorder the nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(dvd.network))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(ordered_adjacency_matrix, main="Reordered Adjacency Matrix Based on Community for Music Network", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(dvd.network)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(dvd.network)$name[ordered_indices], las=2, cex.axis=0.7)
```

###### undirected
```{r}
# change the network to undirected
undirected_dvd_network <- as.undirected(dvd.network, mode="collapse")

# Detect communities using the fastgreedy algorithm
communities <- cluster_fast_greedy(undirected_dvd_network)

# Get the membership vector
membership <- membership(communities)

# Calculate modularity to quantify the strength of the detected communities
modularity_value <- modularity(communities)
print(paste("Modularity:", modularity_value))

# Identify the number of communities
num_communities <- length(unique(membership))
print(paste("Number of Communities:", num_communities))

# List the members of each community
community_list <- split(V(undirected_dvd_network)$name, membership)
community_list

# Reorder the nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(undirected_dvd_network))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(ordered_adjacency_matrix, main="Reordered Adjacency Matrix Based on Community", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(undirected_dvd_network)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(undirected_dvd_network)$name[ordered_indices], las=2, cex.axis=0.7)
```



