---
title: 'PSTAT 194CS Final Project'
author: "Kai Wa Ho, Jingtang, Mu Niu"
date: "2024-06-03"
output: pdf_document
---


```{r, message=FALSE}
# library
library(readr)
library(igraph)
library(rsample)
library(plotly)
```


```{r}
amz <- readRDS(file = '../data/amz_igraph.rds')

amz
```


## 2. Generate 4 Induced Subgraphs:


Methodology: for each subgraph, randomly select one node from music, book, video, DVD, and keep retrieving the nodes that are connected/related to it until reach 200 nodes


* Nodes Retrieving Function:

```{r}
# Function to retrieve connected nodes up to a given count
retrieve_connected_nodes <- function(graph, start_node, count = 30) {
  # Initialize the list with the start node
  nodes_to_explore <- list(start_node)
  connected_nodes <- c(start_node)
  
  # Keep a list to avoid revisiting nodes
  visited_nodes <- numeric(0)
  
  # Explore the graph until we reach the desired number of nodes
  while (length(nodes_to_explore) > 0 && length(connected_nodes) < count) {
    current_node <- nodes_to_explore[[1]]
    nodes_to_explore <- nodes_to_explore[-1]  # Remove the explored node
    
    # Skip if already visited
    if (current_node %in% visited_nodes) next
    
    # Mark as visited
    visited_nodes <- c(visited_nodes, current_node)
    
    # Get neighbors and add to nodes to explore
    neighbors <- neighbors(graph, current_node)
    new_neighbors <- neighbors[!neighbors %in% connected_nodes]
    nodes_to_explore <- c(nodes_to_explore, as.list(new_neighbors))
    connected_nodes <- c(connected_nodes, new_neighbors)
    
    # Limit the collection if it exceeds the desired count
    if (length(connected_nodes) > count) {
      connected_nodes <- connected_nodes[1:count]
      break
    }
  }
  
  # Return the vertex sequence of connected nodes
  return(connected_nodes)
}
```



### Music:


```{r}
# music
set.seed(194)

# randomly select 1 node from music group
music.random = sample(V(amz)[V(amz)$group == "Music"], 1)

# apply function to get 200 related nodes
music.nodes = retrieve_connected_nodes(amz, music.random)
music.network <- induced_subgraph(amz, music.nodes)

# plot
# Choose a layout that spreads out the nodes more effectively
layout <- layout_with_fr(music.network)

# Set graph margins to zero
par(mar = c(0, 0, 2, 0))

# Plot the graph with improved layout and adjusted aesthetics
plot(music.network, layout = layout,
     # Vertex properties
     vertex.color = "#88398A",             # Deep purple color for vertices
     vertex.frame.color = "#FFFFFF",       # White border for vertices for better visibility
     vertex.size = 5,                      # Smaller vertex size to avoid overlap
     vertex.label = V(music.network)$name, # Ensure labels are set to product IDs or similar
     vertex.label.dist = 1,                # Distance of labels from vertices
     vertex.label.cex = 0.8,               # Adjust label size for readability
     vertex.label.color = "black",         # Change label color to black for contrast
     vertex.label.font = 2,                # Bold labels

     # Edge properties
     edge.color = "gray50",                # Lighter color for edges
     edge.width = 0.2,                     # Thinner edges
     edge.arrow.size = 0.1,                # Smaller arrows if directed

     # General plot settings
     main = "Music Products Base Plot", # Add a title if appropriate
     bg = "white" # Background color
)



# Color nodes based on a community detection algorithm to show clusters
music.cluster <- cluster_optimal(music.network)
mycomcols <- c("black", "#D3D3D3", "#88398A")


# Plot the graph with advanced layout and adjusted aesthetics
plot(music.network, layout = layout,
     # Vertex properties
     vertex.color = mycomcols[music.cluster$membership],        # Color vertices by community
     vertex.frame.color = "#FFFFFF",               # White border for vertices for better visibility
     vertex.size = sqrt(degree(music.network)) * 2, # Scale size by square root of degree
     vertex.label = V(music.network)$name,         # Labels are set to product IDs
     vertex.label.dist = 1,                        # Distance of labels from vertices
     vertex.label.cex = 0.6,                       # Adjust label size for readability
     vertex.label.color = "black",                 # Label color for contrast
     vertex.label.font = 2,                        # Bold labels

     # Edge properties
     edge.color = "gray50",                        # Lighter color for edges
     edge.width = 0.2,                             # Thinner edges
     edge.arrow.size = 0.1,                        # Smaller arrows if directed

     # General plot settings
     main = "Music Products Community", # Add a title
     bg = "white" # Background color
)


# Get vertex data including the degree for size scaling
vertex_data <- data.frame(
  Id = V(music.network)$name,
  x = layout[, 1],
  y = layout[, 2],
  degree = degree(music.network),
  Title = V(music.network)$title,
  Group = V(music.network)$group,
  Category = V(music.network)$sub
)

# Enhance hover info by including all attributes except x, y coordinates
vertex_data$hoverinfo <- apply(vertex_data[, -c(2, 3)], 1, function(row) {
  paste(names(row), row, sep=": ", collapse="<br>")
})

# Get edge data
edge_data <- get.data.frame(music.network, what = "edges")

# Join edge data with vertex data to get coordinates for 'from' and 'to'
edge_data <- merge(edge_data, vertex_data, by.x = "from", by.y = "Id", all.x = TRUE)
edge_data <- merge(edge_data, vertex_data, by.x = "to", by.y = "Id", all.x = TRUE, suffixes = c(".from", ".to"))

# Prepare data for Plotly plot
edges <- list(
  x = c(rbind(edge_data$x.from, edge_data$x.to, NA)),
  y = c(rbind(edge_data$y.from, edge_data$y.to, NA)),
  type = "scatter",
  mode = "lines",
  line = list(color = "grey", width = 0.5)
)

nodes <- list(
  x = vertex_data$x,
  y = vertex_data$y,
  hovertext = vertex_data$hoverinfo,
  mode = "markers",  # Only markers, no text
  marker = list(size = vertex_data$degree * 2,
                color = mycomcols[music.cluster$membership]),
  type = "scatter",
  hoverinfo = "text"
)

# Create the plot
plot_ly() %>%
  add_trace(x = edges$x, y = edges$y, mode = edges$mode, type = edges$type, line = edges$line) %>%
  add_trace(x = nodes$x, y = nodes$y, hovertext = nodes$hovertext, mode = nodes$mode, type = nodes$type, hoverinfo = "text", marker = nodes$marker) %>%
  layout(
    title = "Network Visualization of Music Products",
    xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    hovermode = 'closest'
    )
```

```{r}

print(music.network, full = TRUE)
```




### Book:


```{r}
# book
set.seed(194)

# randomly select 1 node from book group
book.random = sample(V(amz)[V(amz)$group == "Book"], 1)

# apply function to get 200 related nodes
book.nodes = retrieve_connected_nodes(amz, book.random)

book.network <- induced_subgraph(amz, book.nodes)

# plot
# Choose a layout that spreads out the nodes more effectively
layout <- layout_with_fr(book.network)

# Set graph margins to zero
par(mar = c(0, 0, 2, 0))

# Plot the graph with improved layout and adjusted aesthetics
plot(book.network, layout = layout,
     # Vertex properties
     vertex.color = "#88398A",             # Deep purple color for vertices
     vertex.frame.color = "#FFFFFF",       # White border for vertices for better visibility
     vertex.size = 5,                      # Smaller vertex size to avoid overlap
     vertex.label = V(book.network)$name, # Ensure labels are set to product IDs or similar
     vertex.label.dist = 1,                # Distance of labels from vertices
     vertex.label.cex = 0.8,               # Adjust label size for readability
     vertex.label.color = "black",         # Change label color to black for contrast
     vertex.label.font = 2,                # Bold labels

     # Edge properties
     edge.color = "gray50",                # Lighter color for edges
     edge.width = 0.2,                     # Thinner edges
     edge.arrow.size = 0.1,                # Smaller arrows if directed

     # General plot settings
     main = "Book Products Base Plot", # Add a title if appropriate
     bg = "white" # Background color
)



# Color nodes based on a community detection algorithm to show clusters
book.cluster <- cluster_optimal(book.network)
mycomcols <- c("black", "#D3D3D3", "#88398A")


# Plot the graph with advanced layout and adjusted aesthetics
plot(book.network, layout = layout,
     # Vertex properties
     vertex.color = mycomcols[book.cluster$membership],        # Color vertices by community
     vertex.frame.color = "#FFFFFF",               # White border for vertices for better visibility
     vertex.size = sqrt(degree(book.network)) * 2, # Scale size by square root of degree
     vertex.label = V(book.network)$name,         # Labels are set to product IDs
     vertex.label.dist = 1,                        # Distance of labels from vertices
     vertex.label.cex = 0.6,                       # Adjust label size for readability
     vertex.label.color = "black",                 # Label color for contrast
     vertex.label.font = 2,                        # Bold labels

     # Edge properties
     edge.color = "gray50",                        # Lighter color for edges
     edge.width = 0.2,                             # Thinner edges
     edge.arrow.size = 0.1,                        # Smaller arrows if directed

     # General plot settings
     main = "Book Products Community", # Add a title
     bg = "white" # Background color
)


# Get vertex data including the degree for size scaling
vertex_data <- data.frame(
  Id = V(book.network)$name,
  x = layout[, 1],
  y = layout[, 2],
  degree = degree(book.network),
  Title = V(book.network)$title,
  Group = V(book.network)$group,
  Category = V(book.network)$sub
)

# Enhance hover info by including all attributes except x, y coordinates
vertex_data$hoverinfo <- apply(vertex_data[, -c(2, 3)], 1, function(row) {
  paste(names(row), row, sep=": ", collapse="<br>")
})

# Get edge data
edge_data <- get.data.frame(book.network, what = "edges")

# Join edge data with vertex data to get coordinates for 'from' and 'to'
edge_data <- merge(edge_data, vertex_data, by.x = "from", by.y = "Id", all.x = TRUE)
edge_data <- merge(edge_data, vertex_data, by.x = "to", by.y = "Id", all.x = TRUE, suffixes = c(".from", ".to"))

# Prepare data for Plotly plot
edges <- list(
  x = c(rbind(edge_data$x.from, edge_data$x.to, NA)),
  y = c(rbind(edge_data$y.from, edge_data$y.to, NA)),
  type = "scatter",
  mode = "lines",
  line = list(color = "grey", width = 0.5)
)

nodes <- list(
  x = vertex_data$x,
  y = vertex_data$y,
  hovertext = vertex_data$hoverinfo,
  mode = "markers",  # Only markers, no text
  marker = list(size = vertex_data$degree * 2,
                color = mycomcols[book.cluster$membership]),
  type = "scatter",
  hoverinfo = "text"
)

# Create the plot
plot_ly() %>%
  add_trace(x = edges$x, y = edges$y, mode = edges$mode, type = edges$type, line = edges$line) %>%
  add_trace(x = nodes$x, y = nodes$y, hovertext = nodes$hovertext, mode = nodes$mode, type = nodes$type, hoverinfo = "text", marker = nodes$marker) %>%
  layout(
    title = "Network Visualization of Book Products",
    xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    hovermode = 'closest'
    )
```



* Video:


```{r}
# music
set.seed(194)

# randomly select 1 node from video group
video.random = sample(V(amz)[V(amz)$group == "Video"], 1)

# apply function to get 200 related nodes
video.nodes = retrieve_connected_nodes(amz, video.random)

video.network <- induced_subgraph(amz, video.nodes)

# plot
# Choose a layout that spreads out the nodes more effectively
layout <- layout_with_fr(video.network)

# Set graph margins to zero
par(mar = c(0, 0, 2, 0))

# Plot the graph with improved layout and adjusted aesthetics
plot(video.network, layout = layout,
     # Vertex properties
     vertex.color = "#88398A",             # Deep purple color for vertices
     vertex.frame.color = "#FFFFFF",       # White border for vertices for better visibility
     vertex.size = 5,                      # Smaller vertex size to avoid overlap
     vertex.label = V(video.network)$name, # Ensure labels are set to product IDs or similar
     vertex.label.dist = 1,                # Distance of labels from vertices
     vertex.label.cex = 0.8,               # Adjust label size for readability
     vertex.label.color = "black",         # Change label color to black for contrast
     vertex.label.font = 2,                # Bold labels

     # Edge properties
     edge.color = "gray50",                # Lighter color for edges
     edge.width = 0.2,                     # Thinner edges
     edge.arrow.size = 0.1,                # Smaller arrows if directed

     # General plot settings
     main = "Video Products Base Plot", # Add a title if appropriate
     bg = "white" # Background color
)



# Color nodes based on a community detection algorithm to show clusters
video.cluster <- cluster_optimal(video.network)
mycomcols <- c("black", "#D3D3D3", "#88398A")


# Plot the graph with advanced layout and adjusted aesthetics
plot(video.network, layout = layout,
     # Vertex properties
     vertex.color = mycomcols[video.cluster$membership],        # Color vertices by community
     vertex.frame.color = "#FFFFFF",               # White border for vertices for better visibility
     vertex.size = sqrt(degree(video.network)) * 2, # Scale size by square root of degree
     vertex.label = V(video.network)$name,         # Labels are set to product IDs
     vertex.label.dist = 1,                        # Distance of labels from vertices
     vertex.label.cex = 0.6,                       # Adjust label size for readability
     vertex.label.color = "black",                 # Label color for contrast
     vertex.label.font = 2,                        # Bold labels

     # Edge properties
     edge.color = "gray50",                        # Lighter color for edges
     edge.width = 0.2,                             # Thinner edges
     edge.arrow.size = 0.1,                        # Smaller arrows if directed

     # General plot settings
     main = "Video Products Community", # Add a title
     bg = "white" # Background color
)


# Get vertex data including the degree for size scaling
vertex_data <- data.frame(
  Id = V(video.network)$name,
  x = layout[, 1],
  y = layout[, 2],
  degree = degree(video.network),
  Title = V(video.network)$title,
  Group = V(video.network)$group,
  Category = V(video.network)$sub
)

# Enhance hover info by including all attributes except x, y coordinates
vertex_data$hoverinfo <- apply(vertex_data[, -c(2, 3)], 1, function(row) {
  paste(names(row), row, sep=": ", collapse="<br>")
})

# Get edge data
edge_data <- get.data.frame(video.network, what = "edges")

# Join edge data with vertex data to get coordinates for 'from' and 'to'
edge_data <- merge(edge_data, vertex_data, by.x = "from", by.y = "Id", all.x = TRUE)
edge_data <- merge(edge_data, vertex_data, by.x = "to", by.y = "Id", all.x = TRUE, suffixes = c(".from", ".to"))

# Prepare data for Plotly plot
edges <- list(
  x = c(rbind(edge_data$x.from, edge_data$x.to, NA)),
  y = c(rbind(edge_data$y.from, edge_data$y.to, NA)),
  type = "scatter",
  mode = "lines",
  line = list(color = "grey", width = 0.5)
)

nodes <- list(
  x = vertex_data$x,
  y = vertex_data$y,
  hovertext = vertex_data$hoverinfo,
  mode = "markers",  # Only markers, no text
  marker = list(size = vertex_data$degree * 2,
                color = mycomcols[video.cluster$membership]),
  type = "scatter",
  hoverinfo = "text"
)

# Create the plot
plot_ly() %>%
  add_trace(x = edges$x, y = edges$y, mode = edges$mode, type = edges$type, line = edges$line) %>%
  add_trace(x = nodes$x, y = nodes$y, hovertext = nodes$hovertext, mode = nodes$mode, type = nodes$type, hoverinfo = "text", marker = nodes$marker) %>%
  layout(
    title = "Network Visualization of Video Products",
    xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    hovermode = 'closest'
    )
```


* DVD:


```{r}
# music
set.seed(194)

# randomly select 1 node from music group
dvd.random = sample(V(amz)[V(amz)$group == "DVD"], 1)

# apply function to get 200 related nodes
dvd.nodes = retrieve_connected_nodes(amz, dvd.random)

dvd.network <- induced_subgraph(amz, dvd.nodes)

# plot
# Choose a layout that spreads out the nodes more effectively
layout <- layout_with_fr(dvd.network)

# Set graph margins to zero
par(mar = c(0, 0, 2, 0))

# Plot the graph with improved layout and adjusted aesthetics
plot(dvd.network, layout = layout,
     # Vertex properties
     vertex.color = "#88398A",             # Deep purple color for vertices
     vertex.frame.color = "#FFFFFF",       # White border for vertices for better visibility
     vertex.size = 5,                      # Smaller vertex size to avoid overlap
     vertex.label = V(dvd.network)$name, # Ensure labels are set to product IDs or similar
     vertex.label.dist = 1,                # Distance of labels from vertices
     vertex.label.cex = 0.8,               # Adjust label size for readability
     vertex.label.color = "black",         # Change label color to black for contrast
     vertex.label.font = 2,                # Bold labels

     # Edge properties
     edge.color = "gray50",                # Lighter color for edges
     edge.width = 0.2,                     # Thinner edges
     edge.arrow.size = 0.1,                # Smaller arrows if directed

     # General plot settings
     main = "DVD Products Base Plot", # Add a title if appropriate
     bg = "white" # Background color
)



# Color nodes based on a community detection algorithm to show clusters
dvd.cluster <- cluster_optimal(dvd.network)
mycomcols <- c("black", "#D3D3D3", "#88398A")


# Plot the graph with advanced layout and adjusted aesthetics
plot(dvd.network, layout = layout,
     # Vertex properties
     vertex.color = mycomcols[dvd.cluster$membership],        # Color vertices by community
     vertex.frame.color = "#FFFFFF",               # White border for vertices for better visibility
     vertex.size = sqrt(degree(dvd.network)) * 2, # Scale size by square root of degree
     vertex.label = V(dvd.network)$name,         # Labels are set to product IDs
     vertex.label.dist = 1,                        # Distance of labels from vertices
     vertex.label.cex = 0.6,                       # Adjust label size for readability
     vertex.label.color = "black",                 # Label color for contrast
     vertex.label.font = 2,                        # Bold labels

     # Edge properties
     edge.color = "gray50",                        # Lighter color for edges
     edge.width = 0.2,                             # Thinner edges
     edge.arrow.size = 0.1,                        # Smaller arrows if directed

     # General plot settings
     main = "DVD Products Community", # Add a title
     bg = "white" # Background color
)


# Get vertex data including the degree for size scaling
vertex_data <- data.frame(
  Id = V(dvd.network)$name,
  x = layout[, 1],
  y = layout[, 2],
  degree = degree(dvd.network),
  Title = V(dvd.network)$title,
  Group = V(dvd.network)$group,
  Category = V(dvd.network)$sub
)

# Enhance hover info by including all attributes except x, y coordinates
vertex_data$hoverinfo <- apply(vertex_data[, -c(2, 3)], 1, function(row) {
  paste(names(row), row, sep=": ", collapse="<br>")
})

# Get edge data
edge_data <- get.data.frame(dvd.network, what = "edges")

# Join edge data with vertex data to get coordinates for 'from' and 'to'
edge_data <- merge(edge_data, vertex_data, by.x = "from", by.y = "Id", all.x = TRUE)
edge_data <- merge(edge_data, vertex_data, by.x = "to", by.y = "Id", all.x = TRUE, suffixes = c(".from", ".to"))

# Prepare data for Plotly plot
edges <- list(
  x = c(rbind(edge_data$x.from, edge_data$x.to, NA)),
  y = c(rbind(edge_data$y.from, edge_data$y.to, NA)),
  type = "scatter",
  mode = "lines",
  line = list(color = "grey", width = 0.5)
)

nodes <- list(
  x = vertex_data$x,
  y = vertex_data$y,
  hovertext = vertex_data$hoverinfo,
  mode = "markers",  # Only markers, no text
  marker = list(size = vertex_data$degree * 2,
                color = mycomcols[dvd.cluster$membership]),
  type = "scatter",
  hoverinfo = "text"
)

# Create the plot
plot_ly() %>%
  add_trace(x = edges$x, y = edges$y, mode = edges$mode, type = edges$type, line = edges$line) %>%
  add_trace(x = nodes$x, y = nodes$y, hovertext = nodes$hovertext, mode = nodes$mode, type = nodes$type, hoverinfo = "text", marker = nodes$marker) %>%
  layout(
    title = "Network Visualization of DVD Products",
    xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    hovermode = 'closest'
    )
```











## 4. Analyze Network Metrics
***Music***
```{r}
# Network Metrics
# Density
network_density <- edge_density(music.network)
cat("Network Density:", network_density, "\n")

# Average Path Length
avg_path_length <- average.path.length(music.network, directed = FALSE)
cat("Average Path Length:", avg_path_length, "\n")

# Diameter
network_diameter <- diameter(music.network, directed = FALSE)
cat("Network Diameter:", network_diameter, "\n")

# Node Metrics
# Degree
node_degree <- degree(music.network)
cat("Node Degree:\n")
print(summary(node_degree))

# Betweenness Centrality
node_betweenness <- betweenness(music.network)
cat("Node Betweenness Centrality:\n")
print(summary(node_betweenness))

# Closeness Centrality
node_closeness <- closeness(music.network)
cat("Node Closeness Centrality:\n")
print(summary(node_closeness))

# Eigenvector Centrality
node_eigenvector <- evcent(music.network)$vector
cat("Node Eigenvector Centrality:\n")
print(summary(node_eigenvector))

# Edge Metrics
# Edge Betweenness
edge_betweenness <- edge.betweenness(music.network)
cat("Edge Betweenness:\n")
print(summary(edge_betweenness))
```
***Network Density: 0.2367816***        
The density of the network is approximately 0.237, which means that about 23.7% of all possible edges between nodes are present. This indicates a moderately connected network, suggesting that a fair number of music products are frequently co-purchased or associated with each other, but there is still a significant proportion that are not directly connected.
    
***Average Path Length: 1.889655***       
The average number of steps along the shortest paths for all possible pairs of nodes is about 1.89. This relatively short path length implies that, on average, any two music products in this network are separated by less than two steps, indicating that products are closely related and often co-purchased.
    
***Network Diameter: 3***       
The diameter of the network is 3, which is the longest shortest path between any two nodes in the network. This small diameter suggests that the network is compact, meaning that even the most distantly related products are not far apart in terms of purchase patterns.
    
***Node Degree***       
The degree distribution shows that the minimum degree is 3, and the maximum degree is 27. The median degree is 14, indicating that half of the nodes have at least 14 connections. The mean degree is about 13.73, showing a relatively balanced distribution of connections among nodes. Nodes with higher degrees are likely popular music products frequently purchased with many others.
    
***Node Betweenness Centrality***
Betweenness centrality measures the extent to which a node lies on paths between other nodes. A high mean value (33.767) and a maximum value (185.015) indicate that certain nodes play critical roles as bridges or connectors in the network. These nodes are essential for maintaining the network's overall connectivity and can be key products influencing purchase patterns.
    
***Node Closeness Centrality***
Closeness centrality measures how close a node is to all other nodes in the network. Nodes with higher closeness centrality (closer to the maximum value of 0.02041) can quickly interact with all other nodes, making them influential in spreading information or trends within the network.
    
***Node Eigenvector Centrality***
Eigenvector centrality assigns relative scores to all nodes based on the principle that connections to high-scoring nodes contribute more to the score of the node in question. The maximum value of 1.0 and a mean of 0.46907 indicate that some nodes are highly influential, connected to other well-connected nodes, making them central in the network.
    
***Edge Metrics***
Edge betweenness measures the number of times an edge is part of the shortest path between any two nodes. A mean of 9.141 and a maximum of 71 indicate that some edges are crucial for maintaining the network's structure. These edges often represent key relationships between products that are essential for the flow of connections within the network.
    
***Summary***
The metrics indicate that the music products network is moderately dense, compact, and features nodes and edges with varying levels of influence and connectivity. Some nodes and edges are critical for maintaining the network's overall structure, indicating popular or influential music products and key associations among them.


***Book***
```{r}
# Network Metrics
# Density
network_density <- edge_density(book.network)
cat("Network Density:", network_density, "\n")

# Average Path Length
avg_path_length <- average.path.length(book.network, directed = FALSE)
cat("Average Path Length:", avg_path_length, "\n")

# Diameter
network_diameter <- diameter(book.network, directed = FALSE)
cat("Network Diameter:", network_diameter, "\n")

# Node Metrics
# Degree
node_degree <- degree(book.network)
cat("Node Degree:\n")
print(summary(node_degree))

# Betweenness Centrality
node_betweenness <- betweenness(book.network)
cat("Node Betweenness Centrality:\n")
print(summary(node_betweenness))

# Closeness Centrality
node_closeness <- closeness(book.network)
cat("Node Closeness Centrality:\n")
print(summary(node_closeness))

# Eigenvector Centrality
node_eigenvector <- evcent(book.network)$vector
cat("Node Eigenvector Centrality:\n")
print(summary(node_eigenvector))

# Edge Metrics
# Edge Betweenness
edge_betweenness <- edge.betweenness(book.network)
cat("Edge Betweenness:\n")
print(summary(edge_betweenness))

```



***Video***
```{r}
# Network Metrics
# Density
network_density <- edge_density(video.network)
cat("Network Density:", network_density, "\n")

# Average Path Length
avg_path_length <- average.path.length(video.network, directed = FALSE)
cat("Average Path Length:", avg_path_length, "\n")

# Diameter
network_diameter <- diameter(video.network, directed = FALSE)
cat("Network Diameter:", network_diameter, "\n")

# Node Metrics
# Degree
node_degree <- degree(video.network)
cat("Node Degree:\n")
print(summary(node_degree))

# Betweenness Centrality
node_betweenness <- betweenness(video.network)
cat("Node Betweenness Centrality:\n")
print(summary(node_betweenness))

# Closeness Centrality
node_closeness <- closeness(video.network)
cat("Node Closeness Centrality:\n")
print(summary(node_closeness))

# Eigenvector Centrality
node_eigenvector <- evcent(video.network)$vector
cat("Node Eigenvector Centrality:\n")
print(summary(node_eigenvector))

# Edge Metrics
# Edge Betweenness
edge_betweenness <- edge.betweenness(video.network)
cat("Edge Betweenness:\n")
print(summary(edge_betweenness))

```


## 5. Community Detection
***Music***
```{r}
# Community Detection
# Walktrap Algorithm
walktrap_communities <- cluster_walktrap(music.network)
cat("Walktrap Algorithm:\n")
print(membership(walktrap_communities))
cat("Modularity:", modularity(walktrap_communities), "\n")

# Infomap Algorithm
infomap_communities <- cluster_infomap(music.network)
cat("Infomap Algorithm:\n")
print(membership(infomap_communities))
cat("Modularity:", modularity(infomap_communities), "\n")

# Visualize communities (optional)
par(mfrow=c(1,3))
plot(walktrap_communities, music.network, main="Walktrap Algorithm", vertex.size=10, edge.arrow.size=0.05, vertex.label.cex=0.7, vertex.label.color="black")
plot(infomap_communities, music.network, main="Infomap Algorithm", vertex.size=10, edge.arrow.size=0.05, vertex.label.cex=0.7, vertex.label.color="black")
```





## 6. Adjacency Matrix

### Music

```{r}
# Load igraph library
library(igraph)

# Create the graph object from the edge list
edges_M <- c("219045", "239771",
           "219045", "240889",
           "219045", "269387",
           "230470", "239763",
           "230470", "239764",
           "230470", "239765",
           "230470", "239766",
           "230470", "239767",
           "230470", "239768",
           "230470", "239769",
           "230470", "239771",
           "230470", "239772",
           "239763", "230470",
           "239763", "239764",
           "239763", "239765",
           "239763", "239766",
           "239763", "239768",
           "239763", "239769",
           "239763", "239771",
           "239763", "240889",
           "239763", "240890",
           "239763", "240892",
           "239764", "230470",
           "239764", "239765",
           "239764", "239766",
           "239764", "239771",
           "239764", "240888",
           "239764", "251179",
           "239764", "251180",
           "239764", "269387",
           "239764", "269388",
           "239765", "230470",
           "239765", "239764",
           "239765", "239766",
           "239765", "239769",
           "239765", "239772",
           "239765", "251179",
           "239765", "251180",
           "239765", "270419",
           "239765", "287512",
           "239766", "230470",
           "239766", "239763",
           "239766", "239764",
           "239766", "239765",
           "239766", "239769",
           "239766", "251179",
           "239766", "269388",
           "239766", "270419",
           "239766", "287512",
           "239767", "230470",
           "239767", "239768",
           "239768", "230470",
           "239768", "239763",
           "239768", "239764",
           "239768", "239766",
           "239768", "239767",
           "239768", "240888",
           "239768", "251177",
           "239768", "251179",
           "239768", "270419",
           "239769", "230470",
           "239769", "239763",
           "239769", "239764",
           "239769", "239765",
           "239769", "239766",
           "239769", "251179",
           "239769", "269388",
           "239769", "270419",
           "239771", "239763",
           "239771", "239764",
           "239771", "240888",
           "239771", "240889",
           "239771", "240890",
           "239771", "240891",
           "239771", "240892",
           "239771", "240893",
           "239771", "240894",
           "239771", "240895",
           "239772", "230470",
           "239772", "239764",
           "239772", "239765",
           "239772", "239766",
           "239772", "251180",
           "239772", "270419",
           "239772", "287512",
           "240888", "230470",
           "240888", "239764",
           "240888", "239771",
           "240888", "240889",
           "240888", "240890",
           "240888", "240891",
           "240888", "240892",
           "240888", "240894",
           "240888", "240899",
           "240888", "304504",
           "240889", "239771",
           "240889", "240888",
           "240889", "240890",
           "240889", "240891",
           "240889", "240892",
           "240889", "240893",
           "240889", "240899",
           "240890", "239763",
           "240890", "239771",
           "240890", "240888",
           "240890", "240889",
           "240890", "240891",
           "240891", "239771",
           "240891", "240888",
           "240891", "240889",
           "240891", "240890",
           "240891", "240892",
           "240891", "240893",
           "240891", "240899",
           "240892", "239764",
           "240892", "239771",
           "240892", "240888",
           "240892", "240889",
           "240892", "240891",
           "240892", "240899",
           "240893", "239771",
           "240893", "240889",
           "240893", "240891",
           "240894", "239764",
           "240894", "239771",
           "240894", "240888",
           "240894", "240889",
           "240894", "240890",
           "240894", "240893",
           "240894", "240899",
           "240895", "239771",
           "240895", "240893",
           "240899", "240888",
           "240899", "240889",
           "240899", "240891",
           "240899", "240892",
           "240899", "304504",
           "251177", "239764",
           "251177", "239765",
           "251177", "239766",
           "251177", "239768",
           "251177", "251179",
           "251177", "269388",
           "251179", "239764",
           "251179", "239765",
           "251179", "239766",
           "251179", "239769",
           "251179", "240892",
           "251179", "251180",
           "251179", "269387",
           "251179", "269388",
           "251179", "270419",
           "251180", "230470",
           "251180", "239764",
           "251180", "239765",
           "251180", "239766",
           "251180", "239771",
           "251180", "240892",
           "251180", "251179",
           "251180", "269387",
           "251180", "269388",
           "269387", "219045",
           "269387", "239764",
           "269387", "239766",
           "269387", "239771",
           "269387", "251179",
           "269387", "251180",
           "269387", "269388",
           "269387", "332118",
           "269387", "332119",
           "269388", "239764",
           "269388", "239765",
           "269388", "239766",
           "269388", "251177",
           "269388", "251179",
           "269388", "251180",
           "269388", "269387",
           "269388", "270419",
           "270419", "239764",
           "270419", "239765",
           "270419", "239766",
           "270419", "239769",
           "270419", "251179",
           "270419", "269388",
           "270419", "287512",
           "287512", "239765",
           "287512", "239766",
           "287512", "239772",
           "287512", "240888",
           "287512", "270419",
           "304504", "239771",
           "304504", "240888",
           "304504", "240889",
           "304504", "240899",
           "332118", "230470",
           "332118", "239764",
           "332118", "239771",
           "332118", "240889",
           "332118", "251180",
           "332118", "269387",
           "332118", "332119",
           "332119", "239771",
           "332119", "240889",
           "332119", "251180",
           "332119", "269387",
           "332119", "332118")

edge_data <- get.data.frame(music.network, what = "edges")

# Join edge data with vertex data to get coordinates for 'from' and 'to'
edge_data <- merge(edge_data, vertex_data, by.x = "from", by.y = "Id", all.x = TRUE)
edge_data <- merge(edge_data, vertex_data, by.x = "to", by.y = "Id", all.x = TRUE, suffixes = c(".from", ".to"))

# Prepare data for Plotly plot
edges_m <- list(
  x = c(rbind(edge_data$x.from, edge_data$x.to, NA)),
  y = c(rbind(edge_data$y.from, edge_data$y.to, NA)),
  type = "scatter",
  mode = "lines",
  line = list(color = "grey", width = 0.5)
)


edgelist_M <- matrix(unlist(edges_m), ncol = 2) 

igraph_network_M <- graph.edgelist(edgelist_M, directed = TRUE)

network.adjacency_M <- as_adj(igraph_network_M)

network.adjacency_M

image(Matrix(network.adjacency_M))


```

```{r}
# edgelist <- matrix(unlist(edges), ncol = 2) 
# 
# igraph_network <- graph.edgelist(edgelist, directed = TRUE)
# 
# network.adjacency <- as_adj(igraph_network)
# 
# image(Matrix(network.adjacency))
# 
# network.adjacency


edge_data <- get.data.frame(music.network, what = "edges")

# Join edge data with vertex data to get coordinates for 'from' and 'to'
edge_data <- merge(edge_data, vertex_data, by.x = "from", by.y = "Id", all.x = TRUE)
edge_data <- merge(edge_data, vertex_data, by.x = "to", by.y = "Id", all.x = TRUE, suffixes = c(".from", ".to"))

# Prepare data for Plotly plot
edges_m <- list(
  x = c(rbind(edge_data$x.from, edge_data$x.to, NA)),
  y = c(rbind(edge_data$y.from, edge_data$y.to, NA)),
  type = "scatter",
  mode = "lines",
  line = list(color = "grey", width = 0.5)
)


edgelist_M <- matrix(unlist(edges_m), ncol = 2, byrow = TRUE) 

igraph_network_M <- graph.edgelist(edgelist_M, directed = TRUE)

network.adjacency_M <- as_adj(igraph_network_M)

network.adjacency_M

image(Matrix(network.adjacency_M))

```

```{r}
# Convert the list to a matrix and then to a data frame
edges_matrix <- matrix(unlist(edges_M), ncol = 2, byrow = TRUE)
edges_df <- as.data.frame(edges_matrix, stringsAsFactors = FALSE)
colnames(edges_df) <- c("V1", "V2")

# Print the data frame
print(edges_df)
```


```{r}
# edges_1 <- as.vector(t(as_edgelist(music.network, names = TRUE))) # ignore self loop


edges_list_m <- as_edgelist(music.network, names = TRUE)
edges_1 <- c()
for (edge in 1:nrow(edges_list_m)) {
  from <- edges_list_m[edge, 1]
  to <- edges_list_m[edge, 2]
  # Filter out self-loop edges
  if (from != to) {
    edges_1 <- c(edges, from, to)
  }
}


edgelist_M <- matrix(unlist(edges_1), ncol = 2)

igraph_network_M <- graph.edgelist(edgelist_M, directed = TRUE)

network.adjacency_M <- as_adj(igraph_network_M)

network.adjacency_M

image(Matrix(network.adjacency_M))
```


```{r}
# Load igraph library
library(igraph)

# Assuming 'amz' is your original huge graph dataset
# Load the graph if needed, for example:
# amz <- read_graph("path_to_your_file", format = "edgelist")

# Set seed for reproducibility
set.seed(194)

# Randomly select one node from the music group
music.random <- sample(V(amz)[V(amz)$group == "Music"], 1)

# Apply the function to get the connected nodes
music.nodes <- retrieve_connected_nodes(amz, music.random)

# Create the subgraph based on these nodes
music.network <- induced_subgraph(amz, music.nodes)

# Extract edges as a character vector and filter out self-loops
edges_list <- as_edgelist(music.network, names = TRUE)
filtered_edges <- c()
for (i in 1:nrow(edges_list)) {
  from <- edges_list[i, 1]
  to <- edges_list[i, 2]
  if (from != to) {
    filtered_edges <- c(filtered_edges, from, to)
  }
}

# Create the graph object from filtered edges
g <- graph(filtered_edges, directed = FALSE)

# Generate the adjacency matrix
adj_matrix <- get.adjacency(g, sparse = FALSE)

# View the adjacency matrix
print(adj_matrix)

# Optionally plot the adjacency matrix for verification
image(adj_matrix, main = "Correct Adjacency Matrix", xlab = "Column", ylab = "Row")

```


### Book

```{r}
edges_list_B <- as_edgelist(book.network, names = TRUE)
edges_2 <- c()
for (edge in 1:nrow(edges_list_B)) {
  from <- edges_list_B[edge, 1]
  to <- edges_list_B[edge, 2]
  # Filter out self-loop edges
  if (from != to) {
    edges_2 <- c(edges_2, from, to)
  }
}


edgelist_B <- matrix(unlist(edges_2), ncol = 2)

igraph_network_B <- graph.edgelist(edgelist_B, directed = TRUE)

network.adjacency_B <- as_adj(igraph_network_B)

network.adjacency_B

image(Matrix(network.adjacency_B))
```

```{r}
# Assuming edgelist_B is your matrix of edges
# Convert the matrix to a data frame for easier manipulation
edgelist_df <- as.data.frame(edgelist_B, stringsAsFactors = FALSE)
colnames(edgelist_df) <- c("V1", "V2")

# Convert columns to numeric for proper sorting
edgelist_df$V1 <- as.numeric(edgelist_df$V1)
edgelist_df$V2 <- as.numeric(edgelist_df$V2)

# Order the data frame first by column V1 and then by column V2
edgelist_df <- edgelist_df[order(edgelist_df$V1, edgelist_df$V2), ]

# Print the sorted data frame without row numbers
print(edgelist_df, row.names = FALSE)

# Convert back to matrix if needed
edgelist_B <- as.matrix(edgelist_df)

igraph_network_B <- graph.edgelist(edgelist_B, directed = TRUE)

network.adjacency_B <- as_adj(igraph_network_B)

network.adjacency_B

image(Matrix(network.adjacency_B))
```



### Video

### DVD





