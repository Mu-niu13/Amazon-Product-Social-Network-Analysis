---
title: 'Amazon Product Co-Purchasing Network Analysis'
author: "Mu Niu, Kai Wa Ho, Jingtang"
date: "2024-06-06"
output: pdf_document
---

## Introduction

In this project, we conduct a comprehensive social network analysis on a dataset derived from Amazon's product co-purchasing records. The raw edge data, which was collected on June 1, 2003, from the Amazon website, includes 403,394 nodes representing individual products and 3,387,388 unweighted directed edges indicating frequently co-purchased product pairs. The direction of an edge signifies the order of purchase, with an outward edge from product A to product B indicating that product B is frequently purchased after product A. This dataset is available at [**Amazon Product Co-Purchasing Network**](https://snap.stanford.edu/data/amazon0601.html)**.**

Additionally, the raw nodes data was collected by crawling Amazon's website and encompasses metadata and review information for 548,552 different products, including books, music, DVDs, and video tapes. This dataset provides detailed information such as the product title, sales rank, list of similar products, detailed product categorization, and reviews. This data was collected in the summer of 2006, and it can be accessed at [**Amazon Product Metadata**](https://snap.stanford.edu/data/amazon-meta.html)**.**

After a thorough data cleaning process, we integrated the edge data and node information data, resulting in an igraph object containing 398,688 nodes. Each node has four attributes: ID (unique product ID), Title (product name), Group (class the product belongs to), and Category (subcategory of the class).

The primary objectives of this analysis are to understand the relationships between products, identify co-purchasing patterns and customer shopping behaviors through network data visualization, and explore various network, node, and edge metrics. We aim to interpret these metrics within the network context, apply community detection algorithms, and analyze the resulting communities. Additionally, we will examine the network's adjacency matrix, reorder vertices to highlight patterns, and observe changes in the matrix to identify clearer patterns based on community or connected components.

## Methodology

In this project, we followed a structured approach to process the data, analyze the network, and visualize the results.The data processing procedures began with mapping the nodes information dataset, which was a text file with issues of missing data and inconsistent formats, into a dataframe with four columns: ID, Title, Group, and Category. Subsequently, we filtered out all edges in the edge dataset that connected nodes with missing IDs, product titles, or product groups. This ensured that only valid and complete data was included in the analysis. The mapped nodes information data and filtered edge data was then integrated into an igraph object containing 398,688 nodes with four vertex attributes: ID, Title, Group, and Category. The data cleaning process employed packages such as `dplyr` for data manipulation and `igraph` for constructing and managing the igraph object in R.

For sampling methodology, we generated 4 induced subgraphs by using a node-centric approach. For each sub-network, we randomly selected one node as the starting point and retrieved all nodes connected to it. We then iteratively expanded our sample by including nodes connected to the current set of nodes, continuing this process until the specified number of nodes was reached. This sampling method was designed to capture densely connected nodes, facilitating better visualization and understanding of the relationships between products.

This comprehensive methodology enabled us to effectively analyze and interpret the Amazon product co-purchasing network, uncovering valuable insights into customer shopping behaviors and product relationships.

## Analysis

After sampling four sub-networks, each formed by using our previously described sampling method and starting with nodes from the book, music, video, and DVD groups respectively, we visualized the subgraphs. This visualization was performed using the base plot and Plotly package in R to generate both static and interactive plots.

The visualizations revealed several interesting patterns in co-purchasing behavior. For instance, we observed that individuals who purchase education books also tend to listen to R&B, rap, and hip-hop music. This correlation might suggest a demographic overlap between students or educators and fans of these music genres. Additionally, we found that people who buy nonfiction books also favor history books, which is logical as both are grounded in factual content. Travel book enthusiasts were also seen to purchase audiobooks, likely due to the convenience of not carrying physical copies while traveling. Similarly, customers who buy children's books often buy audiobooks, possibly because audiobooks provide a convenient way for babysitters to engage children. In the DVD group, those who enjoy comedy DVDs also show a diverse taste in music, purchasing DJ music, pop, rock, and metal. An intriguing finding was that several memoir nodes were linked to R&B and DJ music, which might suggest that people prefer listening to these genres while reading memoirs. Additionally, we found that individuals interested in business and investment books also showed an interest in books on arts and photography.

These visualizations enhanced our understanding of the relationships between products and allowed us to identify distinct co-purchasing patterns. The interactive plots, containing more detailed information, can be accessed [**here**](https://amazon-product-sna-visualization.netlify.app/)**.** By analyzing these subgraphs, we gained valuable insights into customer behavior and product affinities, which can be leveraged for better marketing strategies and product recommendations.

### Metrics and Community Detection

The study of co-purchase networks offers significant insights into customer behavior, product relationships, and marketing strategies. This analysis focuses on the co-purchase networks of Music, Book, Video, and DVD categories. Each category's network structure is examined through its adjacency matrix and various metrics to understand the connectivity and influential nodes.

In the Music network, a density of 0.237 indicates moderate connectivity with frequent co-purchases. Key metrics such as average path length, degree distribution, and centrality measures (betweenness, closeness, and eigenvector) reveal a balanced network with some influential hubs and strong co-purchase relationships.

The Book network shows lower density (0.137), reflecting a more dispersed structure with significant but less frequent connections. Its metrics indicate moderate connectivity and a few key nodes maintaining network cohesion.

For the Video network, a density of 0.189 suggests moderate connectivity with a compact structure, characterized by average path lengths and strong, though moderately distributed, influential nodes.

Community detection through algorithms like Walktrap, Infomap, and FastGreedy offer deeper insights into each networkâ€™s community dynamics. The Walktrap algorithm, which uses random walks, and Infomap, focusing on information flow compression, both identify smaller, tighter communities. FastGreedy, through hierarchical merging, captures broader community structures with slightly less sharp boundaries.

Each algorithm highlights how products are grouped and connected within the network, with Walktrap and Infomap providing more detailed, smaller communities and FastGreedy offering a broader view. The stability of community structures across different networks and algorithms underscores the robustness of the network's configuration, showing that recommendations and co-purchases propagate through stable, well-defined clusters.

Overall, these analyses not only map out the internal dynamics of product co-purchase networks but also provide actionable insights for optimizing product recommendations and marketing strategies.

### Adjacency Matrix&Reordering Nodes

An adjacency matrix is an essential tool for visualizing and analyzing relationships in social networks. Due to report length constraints, I will first examine the original and reordered matrices of the combined network, which integrates four distinct networks. Then, focusing on the music network as a representative.

Firstly, we began by examining the combined adjacency matrix for four distinct product categories: Music, Book, Video, and DVD. Each cell in the matrix represents a co-purchase relationship between products, with grey cells indicating connections. The matrices showed dense intra-network connections and minimal inter-network interactions, highlighting the stability and strong internal community structures within each category.

For a deeper analysis, we focused on the music network, where we explored its adjacency matrix and employed community detection algorithms such as Walktrap, Infomap, and FastGreedy. These algorithms allowed us to reorder the network, revealing clusters centered around influential nodes like 332118--"Movimiento Music," 251117--"G.I. Blues," and 240889--"De La Soul Is Dead." The consistent appearance of these clusters across different algorithms underscores the network's inherent robustness and stable structure.

Notably, Walktrap and Infomap effectively identified smaller, tightly-knit communities, reflecting specific co-purchasing behaviors. In contrast, FastGreedy captured broader community structures but with less distinct separations. This suggests that while the algorithms detect similar clusters, their mechanisms define these clusters with varying sharpness. Additionally, community detection algorithms seem to aggregate broader communities, which may merge smaller, distinct clusters into larger ones. This can reduce the apparent number of clusters which we see in the original matrix.

Our findings demonstrate how product recommendations and purchases propagate within the network, forming cohesive communities around frequently co-purchased items. This aligns with principles from viral marketing, where understanding these dynamics is crucial for predicting future purchases and optimizing marketing strategies. The observed patterns and clusters provide valuable insights into consumer behavior and the interconnectedness of products within the network, emphasizing the importance of community dynamics in network analysis. Given the consistency of these findings, the detailed analysis of the other networks can be inferred to show similar dynamics, justifying a focus on the music network for this study.

## Conclusion

We analyzed the Amazon product co-purchasing network to understand its structure and dynamics. Initially, we looked at the basic characteristics of the network, which showed moderate density with significant co-purchasing connections among music products. This setup allows us to see clear patterns and clusters, indicating that while many products are connected, they're not all directly linked.

Our study used community detection algorithms like Walktrap, Infomap, and FastGreedy to identify community structures within the network. Walktrap and Infomap were particularly good at finding smaller, closely-knit groups, showing specific buying behaviors among certain products. On the other hand, FastGreedy helped us see larger community structures, providing a broader view of how the network is organized.

We also used visualizations like reordered adjacency matrices to illustrate the network's dense connections and the formation of communities around frequently bought items. These visual tools confirmed that our community detection methods were effective and that the network structure was both robust and stable.

Our analysis of the Amazon product co-purchasing network provides valuable insights for enhancing marketing strategies. We identified clusters and key products that illustrate how recommendations and purchases propagate through the network. This information is crucial for targeting marketing efforts effectively and optimizing product recommendations. The study underscores the importance of understanding community dynamics within these networks, offering essential guidance for developing targeted marketing approaches and improving recommendation systems in e-commerce and marketing.

## References

### Dataset:

-   [**Amazon Product Co-Purchasing Network**](https://snap.stanford.edu/data/amazon0601.html)**:** The edge dataset representing products and their co-purchasing patterns on Amazon.

-   [**Amazon Product Metadata**](https://snap.stanford.edu/data/amazon-meta.html)**:** Metadata for products listed in the Amazon Product Co-Purchasing Network.

### Academic Reference:

-   J. Leskovec, L. Adamic, and B. Adamic. [The Dynamics of Viral Marketing](https://doi.org/10.1145/1232722.1232727). ACM Transactions on the Web (ACM TWEB), 1(1), 2007.

### Further Elaboration:

<https://docs.google.com/document/d/13haJthH50zWkUDmupgW31NK3xq_aHxab41QQLrzKcTQ/edit>

Since we do not have enough space in this report, further analysis and interpretation can be accessed via this link.

### Acknowledgments:

We extend our heartfelt thanks to Isaiah Katz and Dr. Uma Ravat. Their assistance was invaluable, and we couldn't have completed this project without their support.

## Appendices

-   Figures

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# library
library(readr)
library(igraph)
library(rsample)

# Function to retrieve connected nodes up to a given count
retrieve_connected_nodes <- function(graph, start_node, count = 30) {
  # Initialize the list with the start node
  nodes_to_explore <- list(start_node)
  connected_nodes <- c(start_node)
  
  # Keep a list to avoid revisiting nodes
  visited_nodes <- numeric(0)
  
  # Explore the graph until we reach the desired number of nodes
  while (length(nodes_to_explore) > 0 && length(connected_nodes) < count) {
    current_node <- nodes_to_explore[[1]]
    nodes_to_explore <- nodes_to_explore[-1]  # Remove the explored node
    
    # Skip if already visited
    if (current_node %in% visited_nodes) next
    
    # Mark as visited
    visited_nodes <- c(visited_nodes, current_node)
    
    # Get neighbors and add to nodes to explore
    neighbors <- neighbors(graph, current_node)
    new_neighbors <- neighbors[!neighbors %in% connected_nodes]
    nodes_to_explore <- c(nodes_to_explore, as.list(new_neighbors))
    connected_nodes <- c(connected_nodes, new_neighbors)
    
    # Limit the collection if it exceeds the desired count
    if (length(connected_nodes) > count) {
      connected_nodes <- connected_nodes[1:count]
      break
    }
  }
  
  # Return the vertex sequence of connected nodes
  return(connected_nodes)
}

amz <- readRDS(file = '../data/amz_igraph.rds')
# Function to generate and plot the community for a given product group
plot_product_community <- function(group_name, main_title) {
  # Randomly select one node from the specified group
  set.seed(194)
  random_node <- sample(V(amz)[V(amz)$group == group_name], 1)
  
  # Apply function to get 200 related nodes
  nodes <- retrieve_connected_nodes(amz, random_node)
  network <- induced_subgraph(amz, nodes)
  
  # Choose a layout that spreads out the nodes more effectively
  layout <- layout_with_fr(network)
  
  # Set graph margins
  par(mar = c(0, 0, 2, 0))
  
  # Color nodes based on a community detection algorithm to show clusters
  cluster <- cluster_optimal(network)
  mycomcols <- c("black", "#D3D3D3", "#88398A")
  
  # Plot the graph with advanced layout and adjusted aesthetics
  plot(network, layout = layout,
       # Vertex properties
       vertex.color = mycomcols[cluster$membership],        # Color vertices by community
       vertex.frame.color = "#FFFFFF",               # White border for vertices for better visibility
       vertex.size = sqrt(degree(network)) * 2, # Scale size by square root of degree
       vertex.label = V(network)$name,         # Labels are set to product IDs
       vertex.label.dist = 1,                        # Distance of labels from vertices
       vertex.label.cex = 0.6,                       # Adjust label size for readability
       vertex.label.color = "black",                 # Label color for contrast
       vertex.label.font = 2,                        # Bold labels
  
       # Edge properties
       edge.color = "gray50",                        # Lighter color for edges
       edge.width = 0.2,                             # Thinner edges
       edge.arrow.size = 0.1,                        # Smaller arrows if directed
  
       # General plot settings
       main = main_title, # Add a title
       bg = "white" # Background color
  )
}

# Plot the communities in a 2x2 layout
par(mfrow = c(2, 2))

# Music group
plot_product_community("Music", "Music Products Community")

# Book group
plot_product_community("Book", "Book Products Community")

# Video group
plot_product_community("Video", "Video Products Community")

# DVD group
plot_product_community("DVD", "DVD Products Community")
```

Music

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXesONswct9tFSOH6oOdFKIMoGnyUnGckYCNFPEpcqF9hK6ekUv5Y6_tfuz8mV4EGNWVAwUwY6vciG-jG4MzGxlraVLoT7fW95s7uECSLxbMftMbK7kofPjtsu_DIvnX0RmubGtMRyF8kIjdxzaJrm1IUfI?key=h0K1bMW7BkU587zlvlBCtw)

Book

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXc2mQS1hMogVBgcRsimXvnm5HyjKObbh0b6iAImCZSMI3OzB2xZeAGQK8916qcT9q6Pp9_2kwSO1Shr4WwOXxrmLfAQ2TqgFgJG_9u-H3kwhhiglvLuFfRfoZoRPW9lqetuwSd6b32h0StDNaf03tCB5xmu?key=h0K1bMW7BkU587zlvlBCtw)

Video

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXc0cirA6bxIPKbRBjoY2hbl5J73YZoEf9rlqpuJhvP1FjEM8e722ixP4MbDrIHwkI1zuP3tfpy9saR8kU_204hsusP3ynAG6qVPTUYvib3uO-c_pnIP1Vv3zcMMp5y6_P0Wurs2plwi0_mQMlHIbIh-UmGN?key=h0K1bMW7BkU587zlvlBCtw)

DVD

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXews8ePjQRLxghyatuZy0mOtxZbYHykPoXBqIQGqVA3wKNy_qxmN19VqRBLiW2MhQm3vrZjHycVR9Z9t8_2ZvJa9Rbfm7Al_UQsA4pjVrKLiTgUZAUfUbmU4zmSvhrIAR40F90B6UeMGA9RnuWRLVBsZIg?key=h0K1bMW7BkU587zlvlBCtw)

community:

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXfSGWgOKeaOI7qzHNWdOtkWYLIQZ4JtEsP8aYBWKj8QTc_O7OBCZrTyH2YhF6jpB9dGDcMti69W7j3GU6DSjx5vZspl-PFcjMGqaJa63hSUJI5dLLEPCpU0KlTBV4aVUk2IAxPM5BzO88zHPv8UAWvJz6Mu?key=h0K1bMW7BkU587zlvlBCtw)

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXcM4F-P3aqadZ_ArGZ6wn-qiPnpa2LNbVyOSg_D_-cXuKpcdJOXuly3dgOtkiSSv5T6pmuShK6e_sZudHn-KXNWV-p-LCc2Zbefe4Ni7NzjDEGGa6omwCrIcetHG0bKc4TYiN0oEJ_NIKtXWd3NsKwnEO8?key=h0K1bMW7BkU587zlvlBCtw)

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXc5KH2emgCn935pzQkszXzOoU3oUafAKtMYfZRPVK5_eU8tIDrerK8tpE-jmHF3QVTSx_sqDt82KE9mGusfin3_3ir3TMiATzO7597vEfoQgDe-jNVJYR_kG0FBdqzbrJ69pePaNMb--yQiUUSqnOjhLP3l?key=h0K1bMW7BkU587zlvlBCtw)

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXeXLvMfzqVvQWRQFZjEvRlQAfGNjbGmrUf5j0TLb_-UdjgZ9xLaeOF8EByD4V11ij6cafa86izszHeDikZKn-s1HCpNtcuXjrYEHFAjPau47I1sh8Q45UkHYKPDYmPqA9VtS-izLcS-BQijJGPotkj_Y9Id?key=h0K1bMW7BkU587zlvlBCtw)

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXc5KH2emgCn935pzQkszXzOoU3oUafAKtMYfZRPVK5_eU8tIDrerK8tpE-jmHF3QVTSx_sqDt82KE9mGusfin3_3ir3TMiATzO7597vEfoQgDe-jNVJYR_kG0FBdqzbrJ69pePaNMb--yQiUUSqnOjhLP3l?key=h0K1bMW7BkU587zlvlBCtw)

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXfnErLL-IcASsJpoYb6MeCbcXbiiopqCQsPeA8VpvZ7NI1kpnc6RKhepDGJpy4VIIwHASkPmuPY_W4N2hNF_nPd7ZaU7iKxeyAENw-g0I2fVN8sh5FcxYe0I3wmtXvy88FJ6qlIUCduA9tLqO0Mra_wue7g?key=h0K1bMW7BkU587zlvlBCtw)

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXeIBaVzL2ksTIAaYHYMeJNf3_M28rqhfEUEDMRfQaiMXscISFk99ABskS4WYWgXt7gcQp7Cz5aAwLuxb8qvsTyye_x4YpPUojb-kA2gyMGP49jmxHfoHQwD-5DvDaM0kn4tG7FP60MwEO3kexSiZbRt0h06?key=h0K1bMW7BkU587zlvlBCtw)

```{r, echo=FALSE, message=FALSE, warning=FALSE}

# preparsion
library(Matrix)

set.seed(194)

# randomly select 1 node from music group
music.random = sample(V(amz)[V(amz)$group == "Music"], 1)

# apply function to get 200 related nodes
music.nodes = retrieve_connected_nodes(amz, music.random)
music.network <- induced_subgraph(amz, music.nodes)

# randomly select 1 node from book group
book.random = sample(V(amz)[V(amz)$group == "Book"], 1)

# apply function to get 200 related nodes
book.nodes = retrieve_connected_nodes(amz, book.random)

book.network <- induced_subgraph(amz, book.nodes)


# randomly select 1 node from video group
video.random = sample(V(amz)[V(amz)$group == "Video"], 1)

# apply function to get 200 related nodes
video.nodes = retrieve_connected_nodes(amz, video.random)

video.network <- induced_subgraph(amz, video.nodes)

# randomly select 1 node from music group
dvd.random = sample(V(amz)[V(amz)$group == "DVD"], 1)

# apply function to get 200 related nodes
dvd.nodes = retrieve_connected_nodes(amz, dvd.random)

dvd.network <- induced_subgraph(amz, dvd.nodes)

# matrix for combined network
a <- union(music.network,book.network,video.network,dvd.network)
edges_list_F <- as_edgelist(a, names = TRUE)


igraph_network_F <- graph.edgelist(edges_list_F, directed = TRUE)

network.adjacency_F <- as_adj(igraph_network_F)

image(Matrix(network.adjacency_F))

# reordered version

com <- cluster_walktrap(a)
plot(com, a, main="Walktrap Algorithm", vertex.size=10, edge.arrow.size=0.05, vertex.label.cex=0.7, vertex.label.color="black")

# Get the membership vector
mem <- membership(com)

# List the members of each community
community_list <- split(V(a)$name, mem)

# Reorder the nodes based on community membership
ordered_indices <- order(mem)
ordered_adjacency_matrix <- as.matrix(get.adjacency(a))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(ordered_adjacency_matrix, main="Reordered Adjacency Matrix", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(a)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(a)$name[ordered_indices], las=2, cex.axis=0.7)

# music matrix original
adj_matrix <- as_adjacency_matrix(music.network, sparse = FALSE)

# Transpose the adjacency matrix to swap rows and columns
adj_matrix_transposed <- t(adj_matrix)

# Set up the plot with customizations
par(mar = c(5, 5, 4, 2) + 0.1)  # Increase margins for axis labels

# Visualize the transposed adjacency matrix with gridlines and node labels
image(1:nrow(adj_matrix_transposed), 1:ncol(adj_matrix_transposed), adj_matrix_transposed, 
      main = "Adjacency Matrix For Music", 
      xlab = "Nodes", ylab = "Nodes", 
      axes = FALSE, col = c("white", "black"))

# Add gridlines
grid(nx = nrow(adj_matrix_transposed), ny = ncol(adj_matrix_transposed), col = "gray", lty = "dotted")

# Add axis labels with the correct node names
axis(1, at = 1:nrow(adj_matrix_transposed), labels = rownames(adj_matrix_transposed), las = 2, cex.axis = 0.7, tick = FALSE)
axis(2, at = 1:ncol(adj_matrix_transposed), labels = colnames(adj_matrix_transposed), las = 2, cex.axis = 0.7, tick = FALSE)

# music optimal

music.cluster <- cluster_optimal(music.network)
modularity_value <- modularity(music.cluster)
modularity_value

membership <- membership(music.cluster)

# Reorder the nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(music.network))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(t(ordered_adjacency_matrix), main="Reordered Adjacency Matrix for Music Network(Optimal)", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(music.network)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(music.network)$name[ordered_indices], las=2, cex.axis=0.7)

# music walktrap
# Detect communities
communities <- cluster_walktrap(music.network)

# Get the membership vector
membership <- membership(communities)

# List the members of each community
community_list <- split(V(music.network)$name, membership)

# Reorder the nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(music.network))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(t(ordered_adjacency_matrix), main="Reordered Adjacency Matrix for Music Network(Walktrap)", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(music.network)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(music.network)$name[ordered_indices], las=2, cex.axis=0.7)

# music fastgreedy
# change the network to undirected
undirected_music_network <- as.undirected(music.network, mode="collapse")

# Detect communities using the walktrap algorithm
communities <- cluster_fast_greedy(undirected_music_network)

membership <- membership(communities)

# List the members of each community
community_list <- split(V(undirected_music_network)$name, membership)



# Reorder nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- t(as.matrix(get.adjacency(undirected_music_network))[ordered_indices, ordered_indices])

# Plot reordered adjacency matrix with community colors
image(1:nrow((ordered_adjacency_matrix)), 1:ncol(ordered_adjacency_matrix), ordered_adjacency_matrix, col=c("white", "black"), main="Reordered Adjacency Matrix for Music Network(Fastgreedy)", axes=FALSE, )
axis(1, at=1:nrow(ordered_adjacency_matrix), labels=V(undirected_music_network)$name[ordered_indices], las=2, cex.axis=0.5)
axis(2, at=1:ncol(ordered_adjacency_matrix), labels=V(undirected_music_network)$name[ordered_indices], las=2, cex.axis=0.5)

```

-   Code

```{r, eval = FALSE}
# Loading Library
library(readr)
library(igraph)
library(rsample)
library(dplyr)
library(stringr)
library(plotly)

#### Data Cleaning
# read data
meta <- readLines('../data/amazon-meta.txt')

# map into df with 5 columns: Id, Title, Group, Categories, Subcategory
meta <- data.frame(line = meta, stringsAsFactors = FALSE)

filtered_meta <- meta %>%
  mutate(keep = grepl("Id:|title:|group:|categories:", line) |
                 lag(grepl("categories:", line), default = FALSE)) %>%
  filter(keep) %>%
  select(-keep)

# map to df
result <- data.frame(Id = character(),
                     Title = character(),
                     Group = character(),
                     Categories = character(),
                     Subcategory = character(),
                     stringsAsFactors = FALSE)


# Process the data
i <- 1
while (i <= nrow(filtered_meta)) {
  current_row <- filtered_meta$line[i]
  if (grepl("Id:  ", current_row)) {
    # Check if there are at least three more rows and they match the expected titles
    if (i + 4 <= nrow(filtered_meta) &&
        grepl("  title: ", filtered_meta$line[i + 1]) &&
        grepl("  group: ", filtered_meta$line[i + 2]) &&
        grepl("  categories: ", filtered_meta$line[i + 3])) {
      
      # Extract and clean the data
      id <- as.integer(sub("Id:  ", "", filtered_meta$line[i]))
      title <- sub("  title: ", "", filtered_meta$line[i + 1])
      group <- sub("  group: ", "", filtered_meta$line[i + 2])
      categories <- as.integer(sub("  categories: ", "", filtered_meta$line[i + 3]))
      if (categories == 0) {
        subcategory <- NA  # Return NA if categories are 0
      }
      else if (categories > 0){
        if (group %in% c("Music", "Book", "Video")){
          sub <- filtered_meta$line[i + 4]
          subcategory <- str_split(sub, "\\|")[[1]][4] %>% str_replace_all("\\[.*?\\]", "")
          if (subcategory %in% c('Reference', 'Genres')){
            subcategory <- str_split(sub, "\\|")[[1]][5] %>% str_replace_all("\\[.*?\\]", "")
          }
        }
        else if (group == "DVD"){
          sub <- filtered_meta$line[i + 4]
          subcategory <- str_split(sub, "\\|")[[1]][5] %>% str_replace_all("\\[.*?\\]", "")
        }
      }
      # Append to result dataframe
      result <- rbind(result, data.frame(Id = id,
                                         Title = title,
                                         Group = group,
                                         Categories = categories,
                                         Subcategory = subcategory,
                                         stringsAsFactors = FALSE))
      # Move index forward by 4
      i <- i + 5
    }
    else {
      # Skip the current Id and all following rows until next Id or end of data
      i <- i + 1
      while(i <= nrow(filtered_meta) && !grepl("Id:  ", filtered_meta$line[i])) {
        i <- i + 1
      }
    }
  }
}

# write to csv
result %>% write.csv('../data/meta_data.csv')

# read edges data
meta = read.csv('../data/meta_data.csv')
data = read.table("../data/amazon0601.txt")
colnames(data) = c("From", "To")

# keep edges that link nodes we have info on
filtered_data = data[(data$From %in% meta$Id) & (data$To %in% meta$Id), ]

# write to csv
filtered_data %>% write.csv('../data/filtered_data.csv')

# convert to igraph
amz <- graph_from_data_frame(filtered_data, directed = TRUE)

# create attributes for igraph object from meta data
title = c()
group = c()
sub = c()

for (i in V(amz)$name){
  if (as.integer(i) %in% meta$Id){
    title = append(title, meta[meta$Id == as.integer(i), ]$Title)
    group = append(group, meta[meta$Id == as.integer(i), ]$Group)
    sub = append(sub, meta[meta$Id == as.integer(i), ]$Subcategory)
  }
}

# handle missing value
sub[is.na(sub)] <- "missing"

V(amz)$title <- title
V(amz)$group <- group
V(amz)$sub <- sub

# save igraph object
saveRDS(amz, file = '../data/amz_igraph.rds')

amz <- readRDS(file = '../data/amz_igraph.rds')

#### Sampling Method
# Function to retrieve connected nodes up to a given count
retrieve_connected_nodes <- function(graph, start_node, count = 30) {
  # Initialize the list with the start node
  nodes_to_explore <- list(start_node)
  connected_nodes <- c(start_node)
  
  # Keep a list to avoid revisiting nodes
  visited_nodes <- numeric(0)
  
  # Explore the graph until we reach the desired number of nodes
  while (length(nodes_to_explore) > 0 && length(connected_nodes) < count) {
    current_node <- nodes_to_explore[[1]]
    nodes_to_explore <- nodes_to_explore[-1]  # Remove the explored node
    
    # Skip if already visited
    if (current_node %in% visited_nodes) next
    
    # Mark as visited
    visited_nodes <- c(visited_nodes, current_node)
    
    # Get neighbors and add to nodes to explore
    neighbors <- neighbors(graph, current_node)
    new_neighbors <- neighbors[!neighbors %in% connected_nodes]
    nodes_to_explore <- c(nodes_to_explore, as.list(new_neighbors))
    connected_nodes <- c(connected_nodes, new_neighbors)
    
    # Limit the collection if it exceeds the desired count
    if (length(connected_nodes) > count) {
      connected_nodes <- connected_nodes[1:count]
      break
    }
  }
  
  # Return the vertex sequence of connected nodes
  return(connected_nodes)
}

#### Visualization
# Define a function to generate and plot the community for a given product group
plot_product_community <- function(group_name, main_title) {
  set.seed(194)
  # Randomly select one node from the specified group
  random_node <- sample(V(amz)[V(amz)$group == group_name], 1)
  
  # Apply function to get 200 related nodes
  nodes <- retrieve_connected_nodes(amz, random_node)
  network <- induced_subgraph(amz, nodes)
  
  # Choose a layout that spreads out the nodes more effectively
  layout <- layout_with_fr(network)
  
  # Set graph margins to zero
  par(mar = c(0, 0, 2, 0))
  
  # Base plot
  plot(network, layout = layout,
       vertex.color = "#88398A",
       vertex.frame.color = "#FFFFFF",
       vertex.size = 5,
       vertex.label = V(network)$name,
       vertex.label.dist = 1,
       vertex.label.cex = 0.8,
       vertex.label.color = "black",
       vertex.label.font = 2,
       edge.color = "gray50",
       edge.width = 0.2,
       edge.arrow.size = 0.1,
       main = paste(main_title, "Base Plot"),
       bg = "white"
  )
  
  # Community plot
  cluster <- cluster_optimal(network)
  mycomcols <- c("black", "#D3D3D3", "#88398A")
  
  plot(network, layout = layout,
       vertex.color = mycomcols[cluster$membership],
       vertex.frame.color = "#FFFFFF",
       vertex.size = sqrt(degree(network)) * 2,
       vertex.label = V(network)$name,
       vertex.label.dist = 1,
       vertex.label.cex = 0.6,
       vertex.label.color = "black",
       vertex.label.font = 2,
       edge.color = "gray50",
       edge.width = 0.2,
       edge.arrow.size = 0.1,
       main = paste(main_title, "Community"),
       bg = "white"
  )
  
  # Get vertex data including the degree for size scaling
  vertex_data <- data.frame(
    Id = V(network)$name,
    x = layout[, 1],
    y = layout[, 2],
    degree = degree(network),
    Title = V(network)$title,
    Group = V(network)$group,
    Category = V(network)$sub
  )
  
  # Enhance hover info by including all attributes except x, y coordinates
  vertex_data$hoverinfo <- apply(vertex_data[, -c(2, 3)], 1, function(row) {
    paste(names(row), row, sep=": ", collapse="<br>")
  })
  
  # Get edge data
  edge_data <- get.data.frame(network, what = "edges")
  
  # Join edge data with vertex data to get coordinates for 'from' and 'to'
  edge_data <- merge(edge_data, vertex_data, by.x = "from", by.y = "Id", all.x = TRUE)
  edge_data <- merge(edge_data, vertex_data, by.x = "to", by.y = "Id", all.x = TRUE, suffixes = c(".from", ".to"))
  
  # Prepare data for Plotly plot
  edges <- list(
    x = c(rbind(edge_data$x.from, edge_data$x.to, NA)),
    y = c(rbind(edge_data$y.from, edge_data$y.to, NA)),
    type = "scatter",
    mode = "lines",
    line = list(color = "grey", width = 0.5)
  )
  
  nodes <- list(
    x = vertex_data$x,
    y = vertex_data$y,
    hovertext = vertex_data$hoverinfo,
    mode = "markers",
    marker = list(size = vertex_data$degree * 2,
                  color = mycomcols[cluster$membership]),
    type = "scatter",
    hoverinfo = "text"
  )
  
  # Create the plot
  plot_ly() %>%
    add_trace(x = edges$x, y = edges$y, mode = edges$mode, type = edges$type, line = edges$line) %>%
    add_trace(x = nodes$x, y = nodes$y, hovertext = nodes$hovertext, mode = nodes$mode, type = nodes$type, hoverinfo = "text", marker = nodes$marker) %>%
    layout(
      title = paste("Network Visualization of", main_title),
      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
      hovermode = 'closest'
    )
}

# Music group
plot_product_community("Music", "Music Products")

# Book group
plot_product_community("Book", "Book Products")

# Video group
plot_product_community("Video", "Video Products")

# DVD group
plot_product_community("DVD", "DVD Products")

#### Network Metrics
## Music Products
# Density
network_density <- edge_density(music.network)
cat("Network Density:", network_density, "\n")

# Average Path Length
avg_path_length <- average.path.length(music.network, directed = FALSE)
cat("Average Path Length:", avg_path_length, "\n")

# Diameter
network_diameter <- diameter(music.network, directed = FALSE)
cat("Network Diameter:", network_diameter, "\n")

# Node Metrics
# Degree
node_degree <- degree(music.network)
cat("Node Degree:\n")
print(summary(node_degree))

# Betweenness Centrality
node_betweenness <- betweenness(music.network)
cat("Node Betweenness Centrality:\n")
print(summary(node_betweenness))

# Closeness Centrality
node_closeness <- closeness(music.network)
cat("Node Closeness Centrality:\n")
print(summary(node_closeness))

# Eigenvector Centrality
node_eigenvector <- evcent(music.network)$vector
cat("Node Eigenvector Centrality:\n")
print(summary(node_eigenvector))

# Edge Metrics
# Edge Betweenness
edge_betweenness <- edge.betweenness(music.network)
cat("Edge Betweenness:\n")
print(summary(edge_betweenness))

## Book Products
# Density
network_density <- edge_density(book.network)
cat("Network Density:", network_density, "\n")

# Average Path Length
avg_path_length <- average.path.length(book.network, directed = FALSE)
cat("Average Path Length:", avg_path_length, "\n")

# Diameter
network_diameter <- diameter(book.network, directed = FALSE)
cat("Network Diameter:", network_diameter, "\n")

# Node Metrics
# Degree
node_degree <- degree(book.network)
cat("Node Degree:\n")
print(summary(node_degree))

# Betweenness Centrality
node_betweenness <- betweenness(book.network)
cat("Node Betweenness Centrality:\n")
print(summary(node_betweenness))

# Closeness Centrality
node_closeness <- closeness(book.network)
cat("Node Closeness Centrality:\n")
print(summary(node_closeness))

# Eigenvector Centrality
node_eigenvector <- evcent(book.network)$vector
cat("Node Eigenvector Centrality:\n")
print(summary(node_eigenvector))

# Edge Metrics
# Edge Betweenness
edge_betweenness <- edge.betweenness(book.network)
cat("Edge Betweenness:\n")
print(summary(edge_betweenness))

## Video Products
# Network Metrics
# Density
network_density <- edge_density(video.network)
cat("Network Density:", network_density, "\n")

# Average Path Length
avg_path_length <- average.path.length(video.network, directed = FALSE)
cat("Average Path Length:", avg_path_length, "\n")

# Diameter
network_diameter <- diameter(video.network, directed = FALSE)
cat("Network Diameter:", network_diameter, "\n")

# Node Metrics
# Degree
node_degree <- degree(video.network)
cat("Node Degree:\n")
print(summary(node_degree))

# Betweenness Centrality
node_betweenness <- betweenness(video.network)
cat("Node Betweenness Centrality:\n")
print(summary(node_betweenness))

# Closeness Centrality
node_closeness <- closeness(video.network)
cat("Node Closeness Centrality:\n")
print(summary(node_closeness))

# Eigenvector Centrality
node_eigenvector <- evcent(video.network)$vector
cat("Node Eigenvector Centrality:\n")
print(summary(node_eigenvector))

# Edge Metrics
# Edge Betweenness
edge_betweenness <- edge.betweenness(video.network)
cat("Edge Betweenness:\n")
print(summary(edge_betweenness))

## DVD Products
network_density <- edge_density(dvd.network)
cat("Network Density:", network_density, "\n")

# Average Path Length
avg_path_length <- average.path.length(dvd.network, directed = FALSE)
cat("Average Path Length:", avg_path_length, "\n")

# Diameter
network_diameter <- diameter(dvd.network, directed = FALSE)
cat("Network Diameter:", network_diameter, "\n")

# Node Metrics
# Degree
node_degree <- degree(dvd.network)
cat("Node Degree:\n")
print(summary(node_degree))

# Betweenness Centrality
node_betweenness <- betweenness(dvd.network)
cat("Node Betweenness Centrality:\n")
print(summary(node_betweenness))

# Closeness Centrality
node_closeness <- closeness(dvd.network)
cat("Node Closeness Centrality:\n")
print(summary(node_closeness))

# Eigenvector Centrality
node_eigenvector <- evcent(dvd.network)$vector
cat("Node Eigenvector Centrality:\n")
print(summary(node_eigenvector))

# Edge Metrics
# Edge Betweenness
edge_betweenness <- edge.betweenness(dvd.network)
cat("Edge Betweenness:\n")
print(summary(edge_betweenness))

#### Community Detection
## Music
# Walktrap Algorithm
walktrap_communities <- cluster_walktrap(music.network)
cat("Walktrap Algorithm:\n")
print(membership(walktrap_communities))
cat("Modularity:", modularity(walktrap_communities), "\n")

# Infomap Algorithm
infomap_communities <- cluster_infomap(music.network)
cat("Infomap Algorithm:\n")
print(membership(infomap_communities))
cat("Modularity:", modularity(infomap_communities), "\n")

# Visualize communities 
par(mfrow=c(1,3))
plot(walktrap_communities, music.network, main="Walktrap Algorithm", vertex.size=10, edge.arrow.size=0.05, vertex.label.cex=0.7, vertex.label.color="black")
plot(infomap_communities, music.network, main="Infomap Algorithm", vertex.size=10, edge.arrow.size=0.05, vertex.label.cex=0.7, vertex.label.color="black")

## Book
# Walktrap Algorithm
walktrap_communities <- cluster_walktrap(book.network)
cat("Walktrap Algorithm:\n")
print(membership(walktrap_communities))
cat("Modularity:", modularity(walktrap_communities), "\n")

# Infomap Algorithm
infomap_communities <- cluster_infomap(book.network)
cat("Infomap Algorithm:\n")
print(membership(infomap_communities))
cat("Modularity:", modularity(infomap_communities), "\n")

# Visualize communities
par(mfrow=c(1,2))
plot(walktrap_communities, book.network, main="Walktrap Algorithm", vertex.size=10, edge.arrow.size=0.05, vertex.label.cex=0.7, vertex.label.color="black")
plot(infomap_communities, book.network, main="Infomap Algorithm", vertex.size=10, edge.arrow.size=0.05, vertex.label.cex=0.7, vertex.label.color="black")

## Video
# Walktrap Algorithm
walktrap_communities <- cluster_walktrap(video.network)
cat("Walktrap Algorithm:\n")
print(membership(walktrap_communities))
cat("Modularity:", modularity(walktrap_communities), "\n")

# Infomap Algorithm
infomap_communities <- cluster_infomap(video.network)
cat("Infomap Algorithm:\n")
print(membership(infomap_communities))
cat("Modularity:", modularity(infomap_communities), "\n")

# Visualize communities 
par(mfrow=c(1,3))
plot(walktrap_communities, video.network, main="Walktrap Algorithm", vertex.size=10, edge.arrow.size=0.05, vertex.label.cex=0.7, vertex.label.color="black")
plot(infomap_communities, video.network, main="Infomap Algorithm", vertex.size=10, edge.arrow.size=0.05, vertex.label.cex=0.7, vertex.label.color="black")

## DVD
# Walktrap Algorithm
walktrap_communities_dvd <- cluster_walktrap(dvd.network)
cat("Walktrap Algorithm:\n")
print(membership(walktrap_communities_dvd))
cat("Modularity:", modularity(walktrap_communities_dvd), "\n")

# Infomap Algorithm
infomap_communities_dvd <- cluster_infomap(dvd.network)
cat("Infomap Algorithm:\n")
print(membership(infomap_communities_dvd))
cat("Modularity:", modularity(infomap_communities_dvd), "\n")

# Visualize communities
plot(walktrap_communities_dvd, dvd.network, main="Walktrap Algorithm", vertex.size=10, edge.arrow.size=0.05, vertex.label.cex=0.7, vertex.label.color="black")
plot(infomap_communities_dvd, dvd.network, main="Infomap Algorithm", vertex.size=10, edge.arrow.size=0.05, vertex.label.cex=0.7, vertex.label.color="black")

#### Adjacency Matrix
# Create the adjacency matrix
adj_matrix <- as_adjacency_matrix(music.network, sparse = FALSE)

# Transpose the adjacency matrix to swap rows and columns
adj_matrix_transposed <- t(adj_matrix)

# Set up the plot with customizations
par(mar = c(5, 5, 4, 2) + 0.1)  # Increase margins for axis labels

# Visualize the transposed adjacency matrix with gridlines and node labels
image(1:nrow(adj_matrix_transposed), 1:ncol(adj_matrix_transposed), adj_matrix_transposed, 
      main = "Adjacency Matrix For Music", 
      xlab = "Nodes", ylab = "Nodes", 
      axes = FALSE, col = c("white", "black"))

# Add gridlines
grid(nx = nrow(adj_matrix_transposed), ny = ncol(adj_matrix_transposed), col = "gray", lty = "dotted")

# Add axis labels with the correct node names
axis(1, at = 1:nrow(adj_matrix_transposed), labels = rownames(adj_matrix_transposed), las = 2, cex.axis = 0.7, tick = FALSE)
axis(2, at = 1:ncol(adj_matrix_transposed), labels = colnames(adj_matrix_transposed), las = 2, cex.axis = 0.7, tick = FALSE)

#### Re-ordering
# Hierarchical clustering to reorder the adjacency matrix
d <- dist(adj_matrix) # Distance matrix
hc <- hclust(d)       # Hierarchical clustering
order <- hc$order     # Order of the nodes

# Reorder the adjacency matrix
adj_matrix_reordered <- adj_matrix[order, order]

# Set up the plot with customizations
par(mar = c(5, 5, 4, 2) + 0.1)  # Increase margins for axis labels

# Plot the reordered adjacency matrix with gridlines and node labels
image(1:nrow(adj_matrix_reordered), 1:ncol(adj_matrix_reordered), adj_matrix_reordered, 
      main = "Reordered Adjacency Matrix For Music", 
      xlab = "Nodes", ylab = "Nodes", 
      axes = FALSE, col = c("lightpink", "darkblue"))

# Add gridlines
grid(nx = nrow(adj_matrix_reordered), ny = ncol(adj_matrix_reordered), col = "gray", lty = "dotted")

# Add axis labels
axis(1, at = 1:nrow(adj_matrix_reordered), labels = rownames(adj_matrix_reordered), las = 2, cex.axis = 0.7, tick = FALSE)
axis(2, at = 1:ncol(adj_matrix_reordered), labels = colnames(adj_matrix_reordered), las = 2, cex.axis = 0.7, tick = FALSE)

## Optimal
modularity_value <- modularity(music.cluster)
modularity_value

membership <- membership(music.cluster)

# Reorder the nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(music.network))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(t(ordered_adjacency_matrix), main="Reordered Adjacency Matrix for Music Network(Optimal)", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(music.network)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(music.network)$name[ordered_indices], las=2, cex.axis=0.7)

## Walktrap
communities <- cluster_walktrap(music.network)

# Get the membership vector
membership <- membership(communities)

# Calculate modularity to quantify the strength of the detected communities
modularity_value <- modularity(communities)
print(paste("Modularity:", modularity_value))

# Identify the number of communities
num_communities <- length(unique(membership))
print(paste("Number of Communities:", num_communities))

# List the members of each community
community_list <- split(V(music.network)$name, membership)
community_list

# Reorder the nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(music.network))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(t(ordered_adjacency_matrix), main="Reordered Adjacency Matrix for Music Network(Walktrap)", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(music.network)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(music.network)$name[ordered_indices], las=2, cex.axis=0.7)

## Undirected
# change the network to undirected
undirected_music_network <- as.undirected(music.network, mode="collapse")

# Detect communities using the walktrap algorithm
communities <- cluster_fast_greedy(undirected_music_network)

membership <- membership(communities)

# Calculate modularity to quantify the strength of the detected communities
modularity_value <- modularity(communities)
print(paste("Modularity:", modularity_value))

# Identify the number of communities
num_communities <- length(unique(membership))
print(paste("Number of Communities:", num_communities))

# List the members of each community
community_list <- split(V(undirected_music_network)$name, membership)
community_list



# Reorder nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- t(as.matrix(get.adjacency(undirected_music_network))[ordered_indices, ordered_indices])

# Plot reordered adjacency matrix with community colors
image(1:nrow((ordered_adjacency_matrix)), 1:ncol(ordered_adjacency_matrix), ordered_adjacency_matrix, col=c("white", "black"), main="Reordered Adjacency Matrix for Music Network(Fastgreedy)", axes=FALSE, )
axis(1, at=1:nrow(ordered_adjacency_matrix), labels=V(undirected_music_network)$name[ordered_indices], las=2, cex.axis=0.5)
axis(2, at=1:ncol(ordered_adjacency_matrix), labels=V(undirected_music_network)$name[ordered_indices], las=2, cex.axis=0.5)


## Book Original Matrix
edges_list_B <- as_edgelist(book.network, names = TRUE)


igraph_network_B <- graph.edgelist(edges_list_B, directed = TRUE)

network.adjacency_B <- as_adj(igraph_network_B)

network.adjacency_B

image(Matrix(network.adjacency_B))

# Create the adjacency matrix
adj_matrix <- as_adjacency_matrix(book.network, sparse = FALSE)

# Set up the plot with customizations
par(mar = c(5, 5, 4, 2) + 0.1)  # Increase margins for axis labels

# Visualize the adjacency matrix with gridlines and node labels
image(1:nrow(adj_matrix), 1:ncol(adj_matrix), adj_matrix, 
      main = "Adjacency Matrix For Books", 
      xlab = "Nodes", ylab = "Nodes", 
      axes = FALSE, col = c("white", "black"))


# Add axis labels
axis(1, at = 1:nrow(adj_matrix), labels = rownames(adj_matrix), las = 2, cex.axis = 0.7, tick = FALSE)
axis(2, at = 1:ncol(adj_matrix), labels = colnames(adj_matrix), las = 2, cex.axis = 0.7, tick = FALSE)

### Reorder vertices to highlight patterns.
# Hierarchical clustering to reorder the adjacency matrix
d <- dist(adj_matrix) # Distance matrix
hc <- hclust(d)       # Hierarchical clustering
order <- hc$order     # Order of the nodes

# Reorder the adjacency matrix
adj_matrix_reordered <- adj_matrix[order, order]

# Set up the plot with customizations
par(mar = c(5, 5, 4, 2) + 0.1)  # Increase margins for axis labels

# Plot the reordered adjacency matrix with gridlines and node labels
image(1:nrow(adj_matrix_reordered), 1:ncol(adj_matrix_reordered), adj_matrix_reordered, 
      main = "Reordered Adjacency Matrix For Books", 
      xlab = "Nodes", ylab = "Nodes", 
      axes = FALSE, col = c("lightpink", "darkblue"))

# Add gridlines
grid(nx = nrow(adj_matrix_reordered), ny = ncol(adj_matrix_reordered), col = "gray", lty = "dotted")

# Add axis labels
axis(1, at = 1:nrow(adj_matrix_reordered), labels = rownames(adj_matrix_reordered), las = 2, cex.axis = 0.7, tick = FALSE)
axis(2, at = 1:ncol(adj_matrix_reordered), labels = colnames(adj_matrix_reordered), las = 2, cex.axis = 0.7, tick = FALSE)

# Detect communities
communities <- cluster_walktrap(book.network)

# Get the membership vector
membership <- membership(communities)

# Calculate modularity to quantify the strength of the detected communities
modularity_value <- modularity(communities)
print(paste("Modularity:", modularity_value))

# Identify the number of communities
num_communities <- length(unique(membership))
print(paste("Number of Communities:", num_communities))

# List the members of each community
community_list <- split(V(book.network)$name, membership)
community_list

# Reorder the nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(book.network))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(ordered_adjacency_matrix, main="Reordered Adjacency Matrix Based on Community for Book Network", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(book.network)$name[ordered_indices], las=2, cex.axis=0.7)

# change the network to undirected
undirected_book_network <- as.undirected(book.network, mode="collapse")

# Detect communities using the fastgreedy algorithm
communities <- cluster_fast_greedy(undirected_book_network)

# Get the membership vector
membership <- membership(communities)

# Calculate modularity to quantify the strength of the detected communities
modularity_value <- modularity(communities)
print(paste("Modularity:", modularity_value))

# Identify the number of communities
num_communities <- length(unique(membership))
print(paste("Number of Communities:", num_communities))

# List the members of each community
community_list <- split(V(undirected_book_network)$name, membership)
community_list

# Reorder the nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(undirected_book_network))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(ordered_adjacency_matrix, main="Reordered Adjacency Matrix Based on Community", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(undirected_book_network)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(undirected_book_network)$name[ordered_indices], las=2, cex.axis=0.7)

## Video
edges_list_V <- as_edgelist(video.network, names = TRUE)


igraph_network_V <- graph.edgelist(edges_list_V, directed = TRUE)

network.adjacency_V <- as_adj(igraph_network_V)

network.adjacency_V

image(Matrix(network.adjacency_V))

# Create the adjacency matrix
adj_matrix <- as_adjacency_matrix(video.network, sparse = FALSE)

# Set up the plot with customizations
par(mar = c(5, 5, 4, 2) + 0.1)  # Increase margins for axis labels

# Visualize the adjacency matrix with gridlines and node labels
image(1:nrow(adj_matrix), 1:ncol(adj_matrix), adj_matrix, 
      main = "Adjacency Matrix For Videos", 
      xlab = "Nodes", ylab = "Nodes", 
      axes = FALSE, col = c("white", "black"))


# Add axis labels
axis(1, at = 1:nrow(adj_matrix), labels = rownames(adj_matrix), las = 2, cex.axis = 0.7, tick = FALSE)
axis(2, at = 1:ncol(adj_matrix), labels = colnames(adj_matrix), las = 2, cex.axis = 0.7, tick = FALSE)

# Hierarchical clustering to reorder the adjacency matrix
d <- dist(adj_matrix) # Distance matrix
hc <- hclust(d)       # Hierarchical clustering
order <- hc$order     # Order of the nodes

# Reorder the adjacency matrix
adj_matrix_reordered <- adj_matrix[order, order]

# Set up the plot with customizations
par(mar = c(5, 5, 4, 2) + 0.1)  # Increase margins for axis labels

# Plot the reordered adjacency matrix with gridlines and node labels
image(1:nrow(adj_matrix_reordered), 1:ncol(adj_matrix_reordered), adj_matrix_reordered, 
      main = "Reordered Adjacency Matrix For Videos", 
      xlab = "Nodes", ylab = "Nodes", 
      axes = FALSE, col = c("lightpink", "darkblue"))

# Add gridlines
grid(nx = nrow(adj_matrix_reordered), ny = ncol(adj_matrix_reordered), col = "gray", lty = "dotted")

# Add axis labels
axis(1, at = 1:nrow(adj_matrix_reordered), labels = rownames(adj_matrix_reordered), las = 2, cex.axis = 0.7, tick = FALSE)
axis(2, at = 1:ncol(adj_matrix_reordered), labels = colnames(adj_matrix_reordered), las = 2, cex.axis = 0.7, tick = FALSE)

# Detect communities
communities <- cluster_walktrap(video.network)

# Get the membership vector
membership <- membership(communities)

# Calculate modularity to quantify the strength of the detected communities
modularity_value <- modularity(communities)
print(paste("Modularity:", modularity_value))

# Identify the number of communities
num_communities <- length(unique(membership))
print(paste("Number of Communities:", num_communities))

# List the members of each community
community_list <- split(V(video.network)$name, membership)
community_list

# Reorder the nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(video.network))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(ordered_adjacency_matrix, main="Reordered Adjacency Matrix Based on Community for Video Network", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(video.network)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(video.network)$name[ordered_indices], las=2, cex.axis=0.7)

# change the network to undirected
undirected_video_network <- as.undirected(video.network, mode="collapse")

# Detect communities using the fastgreedy algorithm
communities <- cluster_fast_greedy(undirected_video_network)

# Get the membership vector
membership <- membership(communities)

# Calculate modularity to quantify the strength of the detected communities
modularity_value <- modularity(communities)
print(paste("Modularity:", modularity_value))

# Identify the number of communities
num_communities <- length(unique(membership))
print(paste("Number of Communities:", num_communities))

# List the members of each community
community_list <- split(V(undirected_video_network)$name, membership)
community_list

# Reorder the nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(undirected_video_network))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(ordered_adjacency_matrix, main="Reordered Adjacency Matrix Based on Community", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(undirected_video_network)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(undirected_video_network)$name[ordered_indices], las=2, cex.axis=0.7)

edges_list_D <- as_edgelist(dvd.network, names = TRUE)


igraph_network_D <- graph.edgelist(edges_list_D, directed = TRUE)

network.adjacency_D <- as_adj(igraph_network_D)

network.adjacency_D

image(Matrix(network.adjacency_D))

# Create the adjacency matrix
adj_matrix <- as_adjacency_matrix(dvd.network, sparse = FALSE)

# Set up the plot with customizations
par(mar = c(5, 5, 4, 2) + 0.1)  # Increase margins for axis labels

# Visualize the adjacency matrix with gridlines and node labels
image(1:nrow(adj_matrix), 1:ncol(adj_matrix), adj_matrix, 
      main = "Adjacency Matrix For DVD", 
      xlab = "Nodes", ylab = "Nodes", 
      axes = FALSE, col = c("white", "black"))



# Add axis labels
axis(1, at = 1:nrow(adj_matrix), labels = rownames(adj_matrix), las = 2, cex.axis = 0.7, tick = FALSE)
axis(2, at = 1:ncol(adj_matrix), labels = colnames(adj_matrix), las = 2, cex.axis = 0.7, tick = FALSE)

### Reorder vertices to highlight patterns.
# Hierarchical clustering to reorder the adjacency matrix
d <- dist(adj_matrix) # Distance matrix
hc <- hclust(d)       # Hierarchical clustering
order <- hc$order     # Order of the nodes

# Reorder the adjacency matrix
adj_matrix_reordered <- adj_matrix[order, order]

# Set up the plot with customizations
par(mar = c(5, 5, 4, 2) + 0.1)  # Increase margins for axis labels

# Plot the reordered adjacency matrix with gridlines and node labels
image(1:nrow(adj_matrix_reordered), 1:ncol(adj_matrix_reordered), adj_matrix_reordered, 
      main = "Reordered Adjacency Matrix For DVD", 
      xlab = "Nodes", ylab = "Nodes", 
      axes = FALSE, col = c("lightpink", "darkblue"))

# Add gridlines
grid(nx = nrow(adj_matrix_reordered), ny = ncol(adj_matrix_reordered), col = "gray", lty = "dotted")

# Add axis labels
axis(1, at = 1:nrow(adj_matrix_reordered), labels = rownames(adj_matrix_reordered), las = 2, cex.axis = 0.7, tick = FALSE)
axis(2, at = 1:ncol(adj_matrix_reordered), labels = colnames(adj_matrix_reordered), las = 2, cex.axis = 0.7, tick = FALSE)

# Detect communities
communities <- cluster_walktrap(dvd.network)

# Get the membership vector
membership <- membership(communities)

# Calculate modularity to quantify the strength of the detected communities
modularity_value <- modularity(communities)
print(paste("Modularity:", modularity_value))

# Identify the number of communities
num_communities <- length(unique(membership))
print(paste("Number of Communities:", num_communities))

# List the members of each community
community_list <- split(V(dvd.network)$name, membership)
community_list

# Reorder the nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(dvd.network))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(ordered_adjacency_matrix, main="Reordered Adjacency Matrix Based on Community for DVD Network", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(dvd.network)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(dvd.network)$name[ordered_indices], las=2, cex.axis=0.7)

# change the network to undirected
undirected_dvd_network <- as.undirected(dvd.network, mode="collapse")

# Detect communities using the fastgreedy algorithm
communities <- cluster_fast_greedy(undirected_dvd_network)

# Get the membership vector
membership <- membership(communities)

# Calculate modularity to quantify the strength of the detected communities
modularity_value <- modularity(communities)
print(paste("Modularity:", modularity_value))

# Identify the number of communities
num_communities <- length(unique(membership))
print(paste("Number of Communities:", num_communities))

# List the members of each community
community_list <- split(V(undirected_dvd_network)$name, membership)
community_list

# Reorder the nodes based on community membership
ordered_indices <- order(membership)
ordered_adjacency_matrix <- as.matrix(get.adjacency(undirected_dvd_network))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(ordered_adjacency_matrix, main="Reordered Adjacency Matrix Based on Community", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(undirected_dvd_network)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(undirected_dvd_network)$name[ordered_indices], las=2, cex.axis=0.7)

edges_list_F <- as_edgelist(a, names = TRUE)


igraph_network_F <- graph.edgelist(edges_list_F, directed = TRUE)

network.adjacency_F <- as_adj(igraph_network_F)

network.adjacency_F

image(Matrix(network.adjacency_F))

com <- cluster_walktrap(a)
plot(com, a, main="Walktrap Algorithm", vertex.size=10, edge.arrow.size=0.05, vertex.label.cex=0.7, vertex.label.color="black")

# Get the membership vector
mem <- membership(com)

# List the members of each community
community_list <- split(V(a)$name, mem)
community_list

# Reorder the nodes based on community membership
ordered_indices <- order(mem)
ordered_adjacency_matrix <- as.matrix(get.adjacency(a))[ordered_indices, ordered_indices]

# Plot the reordered adjacency matrix
image(ordered_adjacency_matrix, main="Reordered Adjacency Matrix", xlab="Nodes", ylab="Nodes", axes=FALSE, col=c("white", "black"))
axis(1, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(a)$name[ordered_indices], las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length.out=length(ordered_indices)), labels=V(a)$name[ordered_indices], las=2, cex.axis=0.7)
```
